# NullPointerException
자바는 언어 설계상 비원시 타입 변수 또는 비원시 타입 메서드 반환값에 null을 저장할 수 있으며 이를 막을 방법도 없다.
개발자는 다음과 같이 센티널값이 필요할 때 null을 다양한 의미로 활용하곤 한다.

* 객체 생성 도중 또는 배열 생성 직후 초기화되지 않은 값
* 처음 사용될 때 non-null 값이 할당될 예정인 지연된 초기화 값
* 명시되지 않은 값
* 찾을 수 없는 값
* 빈 컬렉션을 나타내는 센티널

이 외에도 null은 갖가지 용도로 쓰인다. 문제는 null 값 자체는 아무 의미도 없다는 것이다.
자바 개발자에게는 으레 다음과 같은 질문이 뒤 따른다.
`이 값이 null이 담길 가능성이 있는가?`, `그렇다면 null은 정확히 어떤 의미를 지녔는가?`

다음은 `NullPointerException` 예외를 줄이기 위한 주요 원칙들이다.
* 가능한 코드베이스에 null 값을 사용하지 않는다.
* 값이 부재할 가능성이 있다면 Optional 타입을 사용한다.
* 애노테이션을 이용해 null 가능 여부를 명시하고 자바 타입 시스템을 보강한다.
* 잠재적인 `NullPointerException` 문제를 감지할 수 있는 프로시저 간 정적 분석 도구를 사용한다.

## null 회피와 방어적 검사
입력 받는 모든 참조 파라미터마다 메서드 진입점에서 `Objects.requireNonNull()`을 호출하기만 하면된다.

```java
import java.util.Objects;

public class Person {
    private final String firstName;
    private final String lastName;

    public Person(String firstName, String lastName) {
        this.firstName = Objects.requireNonNull(firstName);
        this.lastName = Objects.requireNonNull(lastName);
    }
}
```
null이 필드에 저장되는 것을 방어하지 않으면 결과적으로 훨씬 나중에, 필드를 실제 참조하는 순간 예외가 발생한다.
이 코드는 `NullPointerExcepton`의 포착 시점을 앞당기는 효과를 낸다.

다음과 같이 메서드 진입점에서 컬렉션을 순회하며 null 포함여부를 확인할 수 있다.

```java
import java.util.Objects;

public void process(Collection<String> data) {
    data.forEach(Objects::requireNonNull);
    ...
}
```
아쉽지만 컬렉션 순회에는 대가가 따른다.
컬렉션 순회에 드는 CPU 실행 시간은 컬렉션의 크기에 달려있다.
특히, 동일한 컬렉션이 여러 메서드에 전달되고 메서드마다 이를 순회하는 상황은 용납될 수 없다.
이 경우 자바 10부터 제공되는 `List.copyOf()`, `Set.copyOf()`, `Map.copyOf()` 등의 컬렉션 팩토리 메서드가 하나의 해결책이 될 수 있다.

```java
import java.util.List;

public void process(Collection<String> data) {
    data = List.copyOf(data);
    ...
}
```
이러한 메서드는 수정 불가 복사본을 생성하며 null을 허용하지 않는다.
더 중요한 점은, 입력된 컬렉션이 이미 `copyOf()` 메서드의 반환 결과일 경우 복사본을 추가로 만들지 않고 인수를 그대로 반환한다는 것이다.
따라서 동일한 컬렉션을 여러 메서드에 전달하고 각 메서드에서 `copyOf()`를 호출하면 객체 복사와 null 검사가 최대 한 번 실행된다.

이제부터 설명할 데이터 타입들에 null을 쓰는 것은 명백히 나쁜 관행으로 간주된다.
* 컬렉션, 이터러블, 배열, 맵
  * 이 타입에서 데이터의 부재는 일반적으로 빈 컬렉션, 빈 배열, 빈 맵 등으로 표현한다.
  * null과 빈 컬렉션에 각기 다른 의미를 부여하는 것은 나쁜 관행이다.
  * 컬렉션, 배열, 맵 등에 원소로 담긴 null과, 컬렉션 자체를 나타내는 null을 명확히 구별해야 한다.

```java
import java.util.Collections;

Collection<String> collectionContainingNull() {
    return Collections.singleton(null);
}

Collections<String> nullInsteadOfCollection() {
    return null;
}
```
첫 번째 메서드는 null이 담긴 컬렉션을 반환한다. 
이는 분명 이상적인 방식이며 문제의 소지도 있지만 카끔 이렇게 해야할 때가 있긴 하다. 
그러나 두 번째 메서드처럼 컬렉션 대신 null을 반환하는 일은 절대로 없어야 한다.

* Stream 또는 Optional 타입
  * 결과가 비어있음을 나타낼 때 `Stream.empty()` 또는 `Optional.empty()`를 사용해야 한다.
  * 이러한 타입이 null을 반환하면 특히 더 위험하다.
  * `Stream`과 `Optional` 클래스는 플루언트 호출 체인 스타일로 설계되었으며 반환 결과는 즉시 `map()` 등의 메서드를 호출하는 데 사용되기 때문이다.
* 열거형 타입
  * null 반환 자체가 또 하나의 선택지를 제공하는 것과 다름없으므로 이를 열거형 상수로 직접 추가하는 것이 훨씬 더 바람직하다.
* Boolean 타입
온라인 쇼핑 애플리케이션에서 사용자가 장바구니 항목을 제거하는 기능을 떠올려보자.
해당 항목을 즉시 제거하기에 앞서 위시리스트로 이동시킬지 묻는 창을 표시하려 한다.

```java
boolean shouldMoveToWishList() {
    ...
    // 사용자가 "Yes"를 클릭하면 true를 반환한다.
    // 사용자가 "No"를 선택하면 false를 반환한다.
    // 사용자가 "Cancel"을 선택하면 null을 반환한다.
}

```
이렇게 하는 이유는 이 방법이 가장 쉬워 보이기 때문이다.
게다가 호출 지점도 특별히 고칠 필요가 없다. 그러나 이 코드는 매우 위험하다.

```java
if (shouldMoveToWishList()) {
    addItemToWishList(item);
}
deleteItemFromBasket(item);
```
메서드가 Boolean 타입으로 바뀌어도 이 코드는 컴파일 에러를 일으키지 않는다.
이대로 사요자가 "Cancel" 버튼을 선택하면 if 문 조건이 자동으로 언박싱되고 NullPointerException이 발생한다.

이러한 위험을 감수하기보다는 열거형을 도입하고 세 값을 모두 넣는 편이 훨씬 안전하다.
다음은 여러 콘텍스트에서 공통적으로 재사용할 수 있는 일반적인 열거형이다.

```java
enum UserAnswer {
    YES, NO, CANCEL
}
```
또는 이번 예시에 특화된 열거형을 다음과 같이 선언해도 된다.
```java
enum ItemRemovalRequest {
    REMOVE_FROM_BASKET,
    MOVE_TO_WISH_LIST,
    CANCEL
}
```
기존 if 문은 다음과 같이 switch 문으로 교체할 수 있다.
```java
switch (shouldMoveToWishList()) {
    case REMOVE_FROM_BASKET -> deleteItemFromBasket(item);
    case MOVE_TO_WISH_LIST -> {
        addItemToWishList(item);
        deleteItemFromBasket(item);
    }
    case CANCEL -> {/* 아무 일도 하지 않는다. */}
}
```

> 실수 방지 가이드
* null 유입을 막으려면 API 경계에서 `requireNonNull()` 등의 메서드로 방어하라.
* 입력 컬렉션이 null이 포함됐는지 확인하는 검사는 합리적인 절차지만 성능 측면의 대가를 필요로 하다.
* 변수 타입이 `Collection`, `Stream`, `Optional`일 때 null을 반환하지 않는다. 가능하면 빈 컨테이너를 반환한다.
* 가급적 배열, 컬렉션, 맵에 null 원소를 넣지 않는 것이 좋다.
* 파일 탐색 불가 에러가 발생했을 때 이를 직접 복구할 수 없다면 null을 반환하기보다 상세한 정보가 담긴 예외를 던지는 것이 좋다.
* 열거형 타입으로 null을 반환하는 대신, 이를 나타낼 상수를 열거형 안에 추가한다.
* Integer, Boolean 등 박싱된 원시 타입 변수를 쓰지 않는다. 이들은 null을 저장할 수 있다. 그러나 그것이 의도된 값인지, null의 정확한 의미는 무엇인지 파악하기 어렵다. Boolean으로 null을 반환하지 말고 상수 3개가 담긴 열거형을 선택하라.

## null 대신 Optional 사용하기
비어있는 `Optional`의 주요 목표는 값의 부재를 드러내는 것이다.

```java
import java.util.Optional;

public Optional<User> findUser(String name) {
  if (!userExists(name)) {
    return Optional.empty();
  }
  
  return Optional.of(getExistingUser(name));
}
```
다음은 `Optional` 객체를 얻는 표준적인 세 가지 방법이다.
* `Optional.empty()`: 빈 `Optional`을 얻는다.
* `Optional.of(value)`: 비어 있지 않는 Optional을 얻는다. value가 null이면 NullPointerException이 발생한다.
* `Optional.ofNullable(value)`: value가 null이면 빈 `Optional`을 얻고 그렇지 않으면 value가 담긴 `Optional`을 얻는다.

## 널리티 애노테이션
널리티 애노테이션은 자바에서 NullPointerException을 최소화하는 용도로 널리 쓰인다.
널리티 애노테이션에서 가장 중요한 두 가지는 `@Nullable`과 `@NotNull(@NonNull)`이다.

```java
interface MyInterface {
    @NotNull String getNotNull();
    @Nullable String getNullable();
    
    default void test() {
        if (getNotNull() == null) { // 경고: condition is always false
          ...
        }
        
        System.out.println(getNullable().trim()); // 경고: trim() invocation may cause NullPointerException
    }
}
```

일부 애노테이션 패키지는 전체 클래스 또는 전체 패키지에 기본 널리티를 설정할 수 있다.
이러한 기능은 해당 API가 완전히, 또는 거의 대부분 null을 배제할 때 유용하다.
```java
@NonNullByDefault({DefaultLocation.PARAMETER, DefaultLocation.RETURN_TYPE})
public interface MyInterface {
    String processString(String input);
}
```
이 코드는 `MyInterface`의 모든 메서드 파라미터(PARAMETER)와 반환값(RETURN_TYPE)을 지목하며 비-널을 기본 상태로 설정한다.
따라서 `processString()` 메서드는 null 파라미터를 받지 않으며, null 값을 반환하지도 않는다.
이렇듯 애노테이션을 스면 널리티 스펙을 매우 간단한 방식으로 명시할 수 있다.
 