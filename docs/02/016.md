# 이전 조건의 다음 조건 지배
다음에 살펴볼 문제는 if-else에 나려된 조건이 상호 배타적이지 않을 때 발생한다.
두 개 이상의 조건이 동시에 참이라면 그중 첫 번째 분기만 실행되므로 순서가 중요하다.
한 조건이 다른 조건을 지배하는 특수한 상황도 있다.
X가 참일 때만 Y가 참일 수 있을 때, 조건 X가 조건 Y를 지배한다고 표현한다.

```java
enum Plan {
    CHILD,
    FULL,
    FREE
}

Plan getPlan(int age) {
    if (age >= 6) return Plan.CHILD;
    if (age >= 18) return Plan.FULL;
    
    return Plan.FREE;
}
```

원래 의도는 6세 이상 17세 이하의 고객에게 CHILD 플랜을 배정하는 것이었지만, 조건의 순서가 틀렸다.
`age >= 6`이 `age >= 18`을 지배하므로 결국 `age >= 18`은 절대 참이 될 수 없으며 FULL 플랜이 반환되는 일도 없다.

```java
import java.math.BigDecimal;
import java.math.BigInteger;

BigInteger toBigInteger(Object obj) {
    if (obj instanceof Number) {
        return BigInteger.valueOf(((Number) obj).longValue());
    }

    if (obj instanceof BigInteger) {
        return (BigInteger) obj;
    }

    if (obj instanceof BigDecimal) {
        return ((BigDecimal) obj).toBigInteger();
    }
    
    return BigInteger.ZERO;
}
```
`BigInteger`, `BigDecimal` 클래스는 모두 `Number`라는 추상 클래스를 확장한다.
따라서 둘 다 첫 번째 조건을 만족시키므로 이후의 분기는 아무 쓸모가 없다.

> 실수 방지 가이드

* 연이은 if-else 분기가 있을 때는 테스트 커버리지 보고서를 확인하고 모든 분기에 테스트가 적용되었는지 확인한다. 누락된 분기가 있다면 테스트를 작성하고 적용한다. 조건 지배 문제가 있다면 금세 발견될 것이다.
* 자바 21부터 일련의 instanceof 검사에 switch 패턴을 적용할 수 있게 되었다.
```java
return switch(obj) {
    case BigInteger bigInteger -> bigInteger;
    case BigDecimal bigDecimal -> bigDecimal.toBigInteger();
    case Number number -> BigInteger.valueOf(number.longValue());
    case null, default -> BigInteger.ZERO;
}
```
이 방식의 가장 큰 장점은 조건의 우열 고나계를 자동으로 검사할 수 있다는 것이다.
```java
return switch(obj) {
    case Number number -> BigInteger.valueOf(number.longValue());
    case BigInteger bigInteger -> bigInteger;
    case BigDecimal bigDecimal -> bigDecimal.toBigInteger();
    case null, default -> BigInteger.ZERO;
}
```
다음과 같이 case Number를 처음으로 넣으면 컴파일 에러가 발생한다.

* 각 조건은 가급적 상호 배타적으로 작성한다. 특히 숫자 범위는 양 쪽 경계를 모두 지정한다. 코드는 더 길어지겠지만 조건 순서를 바꿔도 동작은 유지된다.
```java
Plan getPlan(int age) {
    if (age >= 0 && age <= 5) return Plan.FREE;
    if (age >= 6 && age <= 17) return Plan.CHILD;
    if (age >= 18) return Plan.FULL;
    
    throw new IllegalArgumentException("Wrong age: " + age);
}
```