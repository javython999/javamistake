# 누락된 슈퍼클래스 메서드 호출
클래스를 상속할 때 슈퍼클래스 메서드의 기능에 추가 로직을 보강할 때가 종종 있다.
UI 프로그래밍의 서브클래스에서 슈퍼클래스의 UI 이벤트까지 함께 처리하는 경우가 대표적이다.

```java
public void onKeyDown(KeyEvent event) {
    super.onKeyDown(event);
    if (event.getKeyChar() == 'x') {
        ....
    }
}
```

이 경우 반드시 슈퍼클래스 메서드를 명시적으로 호출해야 한다.
그렇지 않으면 표준적으로 정의된 나머지 단축키가 작동하지 않을 것이다.
슈퍼 메서드 호출은 실수로 누락하거나 리팩터링 중 제거되기 쉽다.
컴파일러는 이를 경고하지 않으며 런타임 예외도 발생하지 않는다.
그러나 프로그램은 정상적으로 작동하지 않을 것이다.

때로는 슈퍼클래스 메서드에 기능이 있어도 일부러 호출하지 않기도 한다.
이러한 코드는 분명 실수는 아니지만 좋지 않은 냄새를 풍기게 된다.
일명 `거부된 상속`이라 부르는 문제가 생기기 때문이다.
거부된 상속이란 일반적으로 서브클래스에서 의도적으로 슈퍼클래스의 일부 기능을 제거하는 상황을 뜻한다.
거부된 상속을 발견하면 해당 클래스의 계층 구조를 재검토해야 한다.
상속보다는 위임 구조가 더 어울릴 것이다.

> 실수 방지 가이드

* 구현 상속 메서드, 비추상임에도 오버라이딩해야 하는 메서드 등은 API를 설계할 때 지양해야 한다. 꼭 필요하다면 인터페이스 구조로 설계하는 것이 더 낫다.       
UI 이벤트를 예로 들면, 먼저 KeyListener 인터페이스를 선언하고 UI 컴포넌트에서 리스너를 추가하도록 설계하면 훨씬 견고한 구조가 된다.
* API 설계상 구현 상속이 꼭 필요할 경우에는 오버라이딩 될 비추상 메서드 본문을 비워두는 것이 좋다. 또한 오버라이딩할 필요가 없는 중요 메서드는 final로 선언해야 한다.    
final 메서드 안에서 오버라이드 메서드를 호출하면 중요 기능이 서브클래스에서 누락될 일이 없다.

```java
import java.awt.event.KeyEvent;

public final void onKeyDown(KeyEvent event) {
    ...
    afterKeyDown(event);
}

protected void afterKeyDown(KeyEvent) {}
```