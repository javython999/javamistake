# 조건 연산자와 가변 인수 호출
가변 인수 메서드 호출 내부에서 사용된 조건 연산자도 혼란의 원인 중 하나다.
```java
static void printFormatted(String formatString, Object... params) {
    if (params.length == 0) {
        System.out.printf(formatString, "user");
    } else {
        System.out.printf(formatString, params);
    }
}
```
```java
// Hello, user
printFormatted("Hello, %s%n");

// Hello, administrator
printFormatted("Hello, %s%n", "administrator");
```

다음과 같이 조건 표현식을 활용해 코드를 단축했다.
```java
static void printFormatted(String formatString, Object... params) {
    System.out.printf(formatString, params.length == 0 ? "user" : params);
}
```
```java
// Hello, user
printFormattedRefactoring("Hello, %s%n");

// Hello, [Ljava.lang.Object;@34c45dca
printFormattedRefactoring("Hello, %s%n", "administrator");
```

조건 표현식을 사용하면 컴파일러가 한 쪽 분기만 래핑할 수 없다.
컴파일러는 전체 조건 표현식을 하나로 인식한다. then 분기의 타입이 String이고 else 분기는 Object[]이므로 조건 표현식은 전체 타입은 String과 Object[]의 공통 슈퍼타입인 Object가 된다.
Object는 배열이 아니므로 컴파일러는 이를 배열로 자동 래핑하며 결과적으로 parmas 배열은 또 다른 배열 속으로 들어간다.

```java
static void printFormatted(String formatString, Object... params) {
    System.out.printf(formatString, params.length == 0 ? new Object[]{"user"} : params);
}
```

> 실수 방지 가이드
* 조건 표현식에서 가변 인수를 사용할 때는 주의해야 한다. 가급적이면 if 문을 사용한다.
* 조건 표현식을 고수하고 싶을 때는 IDE의 리팩터링 기능인 'Introduce Variable' 또는 'Extract Variable'로 표현식을 변수로 추출한다.
```java
Object adjustParams = params.length == 0 ? "user" : adjustParams;
System.out.printf("formatString, adjustParams");
```