# 비교 메서드가 반환하는 NaN 값 무시
비교 메서드를 직접 만들면 부동소수점 숫자를 제대로 처리하지 못할 위험이 있다.
```java
class DoubleObj implements Comparable<DoubleObj> {
    final double d;

    DoubleObj (double d) {
        this.d = d;
    }
    
    @Override
    public int compareTo(DoubleObj o) {
        return d == o.d ? 0 : d < o.d ? - 1 : 1;
    }
}
```

```java
DoubleObj x = new DoubleObj(Double.NaN);
DoubleObj y = new DoubleObj(0);

System.out.println(x.compareTo(y) > 0); // true
System.out.println(y.compareTo(x) > 0); // true
System.out.println(x.compareTo(x) > 0); // true
```

이 문제를 해결하는 방법은 직접 만들지 말고 라이브러리 메서들르 사용하는 것이다.

```java
return Double.compare(d, o.d);
```

이 코드는 다른 모든 값보다 `NaN` 값이 크다고 일관되게 판단한다.
또한 이 구현은 `0.0`, `-0.0`을 정렬함으로써 `0.0`을 더 큰 쪽에 둔다.

> 실수 방지 가이드
* 부동소수점 숫자를 비교할 때 `NaN` 값을 처리해야 한다는 사실을 잊으면 안 된다.
* `NaN` 값이 필드에 저장될 가능성이 있다면 이를 제대로 처리하고 있는지 확인하는 유닛 테스트를 작성해야 한다.
그럴 가능성조차 없어야 한다면 필드 할당 조건을 설정하면 된다.
```java
DoubleObj (double d) {
    if (Double.isNaN(d)) {
        throw new IllegalArgumentException();
    }
    
    this.d = d;
}
```
* `Double.compare()`는 `-0.0`이나 `NaN` 등의 특수한 숫자를 처리한다. 이러한 기능은 직접 구현하기보다 라이브러리 메서드를 사용하는 것이 좋다.
라이브러리 메서드는 충분히 테스트되었으며 다양한 코너 케이스를 아우른다.
* `Compartor` 메서드를 구현할 때는 `comparingDouble()` 정적 메서드를 활용한다.