# 비교 메서드에서 객체를 키 시퀀스로 표현하지 못함
여러 필드를 비교하는 일반적인 방법은 각각을 차례로 비교하다가 차이를 확인하면 중단하는 것이다.
```java
class Person implements Comparable<Person> {
    String name;
    int age;
    
    @Override
    public int compareTo(Person o) {
        int res = name.compareTo(o.name);
        if (res != 0) {
            return res;
        }
        return Integer.compare(age, o.age);
    }
}
```
이 코드는 `Guava` 라이브러리의 `ComparisonChain` 유틸리티 이용해 다음과 같이 플루언트 스타일로 작성할 수 있다.

```java
public int compareTo(Person o) {
    return ComparisonChain.start()
            .compare(name, o.name)
            .compare(age, o.age)
            .result();
}
```

`Comparable` 인터페이스 구현체 대신 커스텀 `Comparator`를 만들어야 한다면, 다음과 같이 JDK가 제공하는 조합 메서드로 코드를 간소화할 수 있다.
```java
Comparator<Person> PERSON_COMPARATOR = Comparator.comparing((Persion p) -> p.name)
        .thenComparing(p -> p.age);
```

이러한 조합 메서드는 비교 과정에서 약간의 성능 오버헤드를 유발하지만 실수의 여지도 크게 줄여준다.
다만 `compareTo()` 메서드 안에서 조합 메서드를 사용하는 것은 다소 어색하다.
그럴 때는 다음과 같은 방식으로 비교자에게 위임하면 된다.

```java
class Person implements Comparable<Person> {

    private static final Comparator<Person> MY_COMPARATOR =
            Comparator.comparing((Person p) -> p.name)
                    .thenComparing(p -> p.name);

    String name;
    int age;

    @Override
    public int compareTo(Person o) {
        return MY_COMPARATOR.compare(this, o);
    }
}
```
`Guava` 등의 라이브러리를 사용할 수 없거나, 성능에 민감하지 않은 코드일 경우 이러한 기법을 활용하면 좋다.
객체를 비교할 때에는 순서대로 나열된 키 시퀀스 형태로 하나씩 비교하는 것이 최선이다.
예시는 이 시퀀스를 `name`과 `age` 필드라는 두 개의 키로 구성했다. `compareTo()` 메서드 안에서 불필요한 작업을 수행하면 에러가 발생하기 매우 쉽다.

```java
class Connection implements Comparable<Connection> {
    final String url;
    
    Connection(String url) {
        this.url = url;
    }
    
    @Override
    public int compareTo(Connection that) {
        if (this instanceof SecureConnection) {
            return -1;
        }
        
        if (that instanceof SecureConnection) {
            return 1;
        }
        
        return this.url.compareTo(taht.url);
    }
}

class SecureConnection extends Connection {
    SecureConnection(String url) {
        super(url);
    }
}
```
이 코드는 URL로 컬렉션을 비교하고 보안 연결을 우선 순위에 두는 역할을 한다.
의도는 이처럼 명확했으나, `this`, `that`이 모두 보안 연결일 경우에는 어떻게 될까?
우선 이 코드는 `-1`을 반환하는 곳부터 이미 비교 메서드 계약 위반이다.
`this`와 `that`의 값을 바꾸면 반환 값이 양수로 바뀌어야 하지만 그렇지 않는 경우가 생기기 때문이다.

첫 번째는 `this instanceof SecureConnection`으로 계산하고 반전시킨 boolean 값이다.
두 번째는 url 필드의 문자열 값이다. 따라서 이 코드의 `compareTo()` 구현은 다음과 같이 일반적인 형식으로 고칠 수 있다.
```java
public int compareTo(Connection that) {
    int res = Boolean.compare(
            that instanceof SecureConnection,
            this instanceof SecureConnection);
    
    if (res != 0) {
        return res;
    }
    
    return this.url.compareTo(that.url);
}
```

또는 `Guava`로 다음과 같이 구현할 수 있다.
```java
public int compareTo(Connection that) {
    return ComparisonChain.start()
            .compareTrueFirst(this instanceof SecureConnection, that instanceof SecureConnection)
            .compare(this.url, that.url)
            .result();
}
```
비슷한 실수 중, `null`을 제대로 처리하지 못하는 사례도 꽤 많다.
이 코드는 하나의 `nullable` 필드를 지닌 객체를 비교하는 역할을 한다.
```java
record User(String name) implements Comparable<User> {
    public int compareTo(User o) {
        if (name != null && o.name != null) {
            return name.compareTo(o.name);
        }
        
        return 0;
    }
}
```

이 메서드는 두 name중 한 쪽만 `null`일 경우 0을 반환하는 오류를 범하고 있다.
언뜻 보면 아무 문제도 없어 보이지만 비교 메서드 계약의 세 번째 규칙을 위반하고 있다.

```java
var u1 = new User(null);
var u2 = new User("Mary");
var u3 = new User("Bill");

System.out.println(u1.compareTo(u2)); // 0
System.out.println(u2.compareTo(u3)); // 11
System.out.println(u1.compareTo(u3)); // 0
```

이 셋을 올바르게 비교하려면 객체를 표현하고 있는 두 값의 시퀀스를 만들어야 한다.
첫 번째 값은 `name`의 `null` 여부, 두 번째 값은 `name` 자신이다. 또한 `name == null` 인 객체를 다른 객체보다 앞에 둘지 아니면 뒤에 둘지 결정해야 한다.
후자의 경우, 구현 코드는 다음과 비슷할 것이다.

```java
public int compareTo(User o) {
    int res = Boolean.compare(name == null, o.name == null);
    if (res != 0) {
        return res;
    }
    return name != null ? name.compareTo(o.name) : 0;
}
```

여기에 `nullsFirst()` 또는 `nullsLast()` 조합기를 활용해도 된다.
조합기를 쓰면 성능적 이득은 없지만 가독성은 더 높아진다.

```java
import java.util.Comparator;

import static java.util.Comparator.*;

record User(String name) implements Comparable<User> {
    static final Comparator<User> USER_ORDER = comparing(User::name, nullsLast(naturalOrder()));

    public int compareTo(User o) {
        return USER_ORDER.compare(this, o);
    }
}
```

> 실수 방지 가이드
* 비교 메서드를 구현할 때는 객체를 키 시퀀스로 표현하고 하나씩 비교해본다.
* 가급적이면 `Comparator.comparing()` 등의 비교자 조합 메서드 또는 `Guava`의 `ComparisonChain`을 사용한다.
* 임의의 입력 객체를 생성하는 무작위 프로퍼티 테스트를 만들고 비교자 계약 준수 여부를 검증한다. `TimSort` 알고리즘이 계약 위반을 보고하도록, 충분히 큰 데이터셋(최소 32개 원소)를 만들어 테스트 한다.
* '이럴 때는 순서가 상관없다.'는 생각은 비교자 계약 위반을 유발하는 위험한 발상이다. 서로 다른 두 원소가 어떻게 정렬되든 상관없다 해도, 단순히 0을 반환하는 대신 어떤 식으로든 둘 사이의 순서를 정의해야 한다.