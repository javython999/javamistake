# equals 메서드 대신 참조 동등성 비교
프로그래머들은 종종 `equals()` 대신 `==`를 사용하곤 한다.
그 이유는 아마도 그저 간단히 처리하고 싶었거나, 두 비교 방식의 차이를 망각했기 때문일 것이다.
이러한 실수는 다소 애매한 에러를 유발한다. 실수가 있음에도 불구하고 프로그램은 여전히 잘 동작하는 경우가 있다.

가장 흔한 사례는 `Boolean`, `Integer`, `Long` 등의 원시 래퍼 클래스를 비교할 때 `==`를 쓰는 것이다.
이 클래스들은 자동 방식 과정에서 캐싱 기능을 활용하기 때문에 `==`를 써도 참조 동등성 비교가 작동한다.
`-128 ~ 127` 사이의 `Integer` 값은 언제나 캐싱 된다.
따라서 `==`를 사용하더라도 숫자가 작고 자동 박싱 기능이 작동하면 올바르게 비교할 수 있다.
그러나 비교하는 값이 커지면 캐시에서 객체를 찾을 수 없다. 이 경우 원시 숫자를 `Integer` 변수에 할당할 때마다 새로운 객체가 생성된다.
결국 다음 코드는 두 숫자를 제대로 비교할 수 없다.

```java
Integer i1 = 1000;
Integer i2 = 1000;
System.out.println(i1 == i2);
```

```java
Boolean b1 = true;
Boolean b2 = true;
Boolean b3 = new Boolean(true);

System.out.println(b1 == b2); // true
System.out.println(b1 == b3); // false
```
향후 자바 원시 래퍼의 public 생성자가 제거될 예정이므로 이러한 문제도 언젠가는 사라질 것이다.


`String` 객체를 `==`로 비교하는 실수도 흔히 발생한다.
소스 코드의 `String` 객체가 컴파일 타임 상수로 작동하면 가상 머신에 의해 자동으로 중복제거 되거나 인터닝 된다.
따라서 `==` 비교가 제대로 작동하는 경우도 있다.
하지만 복잡하게 생성된 문자열은 별도의 `String` 객체를 생성하므로 `==`로 비교할 수 없다.

```java
String greeting = "Hello";
System.out.println(greeting == "Hello"); // true
String greeting2 = greeting + "!";
System.out.println(greeting2 == "Hello!"); // false
```

> 실수 방지 가이드
* 원시 래퍼 타입은 절대 참조 동등성 비교를 하면 안된다. 문자열도 마찬가지다. 성능상의 이유로 어쩔수 없이 참조 동등성을 사용하는 경우가 아주 가끔 있지만
이럴 때도 신중한 프로파일링을 통해 결과를 검증해야 한다.
* 원시 래퍼 타입은 가능한 한 사용하지 않는다. 불가피하게 사용할 때는 최대한 빨리 언박싱해야 한다.
