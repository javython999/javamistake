# equals()와 hashCode() 불일치
`equals()`와 `hashCode()`는 IDE에서 자동으로 생성하는 것이 좋다.
그러나 드물게 `equals()` 안에서 IDE의 기본 구현 외에 다른 기능을 처리해야 할 때가 있다.
이렇게 되면 `hashCode()`도 그에 맞게 구현해야 한다.

```java
class TowFields {
    int f1;
    int f2;
    
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        
        TwoField twoField = (TwoField) o;
        return f1 == twoField.f1 && f2 == twoField.f2
            || f1 == twoField.f2 && f2 == twoField.f1;        
    }
}
```
`equals()`와 `hashCode()`를 자동으로 생성하면 이렇듯 특수한 조건을 만들어내지는 못한다.
이 경우 `hashCode()`를 `Objects.hash(f1, f2)`로 구현하면 제대로 작동하지 않을 것이다.
올바른 결과를 얻을려면 f1과 f2를 서로 바꿔도 동일한 결과를 반환하는 대칭 함수가 필요하다.
그러나 `Objects.hash()`는 대칭적이지 않다.
가령 `Objects.hash(1, 2)`는 994를 `Objects.hash(2, 1)`은 1024를 반환한다.

이 경우 가장 간단한 해결책은 다음과 같이 둘을 합산하는 것이다.
```java
public int hashCode() {
    return f1 + f2;
}
```
`java.util.Set`의 구현 코드도 비슷한 접근 방식을 채택했다.
세트의 동등성은 원소의 순서와 무관하기 때문이다.
또 다른 해결책은 객체 생성 및 수정 시 매번 정규화하는 것이다.
불변 객체는 이를 매우 간단하게 구현할 수 있다.
가령 다음은 항상 f1 <= f2를 유지하는 클래스다.

```java
class TowFields {
    int f1;
    int f2;

    TowFields(int f1, int f2) {
        if (f1 <= f2) {
            this.f1 = f1;
            this.f2 = f2;
        } else {
            this.f1 = f2;
            this.f2 = f1;
        }
    }
    
}
```
이런 클래스는 `equals()` 및 `hashCode()`에 커스텀 로직을 구현할 필요가 없다.
따라서 자동 생성 코드도 잘 작동한다. 자바 레코드도 이러한 기법을 적용할 수 있다.

> 실수 방지 가이드
* `equals()`와 `hashCode()`를 구현할 때 해당 객체를 동일한 키 시퀀스로 표현하면 둘 사이에 일관성을 유지할 수 있다.
만일 `hashCode()` 구현에서 `string.toLowerCase(Locale.ROOT)`의 해시코드를 사용한다면, `toLowerCase()`라는 하나의 키를 사용하는 셈이다.
구현의 일관성을 지키려면 `equals()`에서도 다음과 같이 동일한 키로 값을 비교해야 한다.
```java
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    
    if (!(o instanceof CaseInsensitiveString)) {
        return false;
    }
    
    CaseInsensitiveString that = (CaseInsensitiveString) o;
    return string.toLowerCase(Locale.ROOT)
            .equals(that.string.toLowerCase(Locale.ROOT));
}
```
* `equals()` 메서드가 `equalsIgnoreCase()`의 기능적 의미를 충실히 따르게 하려면 다음과 같이 `hashCode()` 구현에서 `toUpperCase()`와 `toLowerCase()`를 모두 실행하면된다.
```java
public int hashCode() {
    return string.toUpperCase(Locale.ROOT)
            .toLowerCase(Locale.ROOT)
            .hashCode();
}
```