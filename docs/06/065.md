# 뺄셈을 이용한 숫자 비교
```java
class IntObj implements Comparable<IntObj> {
    final int i;
    
    IntObj(int i) {
        this.i = i;
    }
    
    @Override
    public int compareTo(IntObj o) {
        return i - o.i;
    }
}
```
숫자를 비교할 때 뺄셈을 쓰면 편리하다.
`compareTo()`는 계약에 따라 1 또는 -1뿐만 아니라 모든 양수나 음수를 반환할 수 있다.
따라서 이 코드는 짧으면서도 올바른 구현으로 보인다.
하지만 큰 숫자를 다룰 때 이 뺄셈은 오버플로를 일으킬 수 있다.
예를 들어 `new IntObj(2_000_000_000)`와 `new IntObj(-2_000_000_000)`라는 두 객체를 생성하고 비교하면 
후자가 더 크다는 결과가 나온다. 이는 전이성 규칙에 위배된다.

```java
IntObj x = new IntObj(2_000_000_000);
IntObj y = new IntObj(0);
IntObj z = new IntObj(-2_000_000_000);

System.out.println(x.compareTo(y) > 0);
System.out.println(y.compareTo(z) > 0);
System.out.println(x.compareTo(z) > 0);
```
이 경우 `compareTo()`를 올바르게 구현하려면 다음과 같이 뺄셈 대신 단순 비교로 판단해야 한다.
```java
return i == o.i ? 0 : i < o.i ? -1 : 1;
```

boolean 필드와 마찬가지로 이 작업도 다음과 같이 전용 라이브러리 메서드를 쓰는 편이 훨씬 낫다.
```java
return Integer.compare(i, o.i);
```
이번 문제는 매우 드문 사례로 보일 것이다.
비교 대상 숫자가 문자열 길이처럼 절대 음수가 되지 않으면 이런 문제는 발생하지 않는다.
또한 숫자의 절댓값이 대략 10억을 넘지 않는 한, 음수도 마찬가지로 안전하다. 그러나 드물게 발생하는 문제가 늘 그렇듯, 이 버그도 아무렇지 않게 테스트를 통과해 프로덕션 코드까지 살아남았던 적이 있다.
2021년 11월, 안드로이드 폰이 특정 상황에서만 911 긴급 전화를 걸지 못하는 사태가 벌어졌다.
사소한 버그가 얼마나 심각한 결과를 초래하는지 이 사례를 통해 조금이나마 상상해보기 바란다.
후속 조사결과, 문제의 근본적인 원인은 이번 절의 주제와 정확히 같았다.
긴급 전화를 연결하기에 앞서 PhoneAccount 객체들이 비교자를 통해 정렬되었고, 통화로 연결한 선호 객체가 최종적으로 결정됐다.
일련의 과정이 끝난 후 마지막 단계에 있던 코드는 다음과 같았다.

```java
return account1.hashCode() - account2.hashCode();
```
이 코드는 모든 int 값을 해시코드로 사용했고, 값이 커지자 실제로 오버플로가 발생하며 정렬 절차가 실패했다.
뺄셈을 `Integer.compare()` 호출로 교체하자 문제는 사라졌다.

비교 메서드의 계약 준수가 그토록 중요한 이유에 대해 혹자는 의문을 제기할 수 있다.
사실, 정렬이 약간 틀려도 무방한 경우가 있을 수 있다.
심지어 잘못된 비교자도 간단한 테스트를 통과하고 적당한 결과를 낼 수 있다.
그러나 입력값이 커질 수록 결과의 파급력도 커진다는 것이 문제다.

> 실수 방지 가이드
* 덧셈 또는 뺄셈 등의 수학적 연산은 오버플로를 일으킬 수 있음을 명심한다.
* `int` 필드를 비교할 때는 `Integer.compare()` 라이브러리 메서드를 사용한다. `Comparator`를 직접 구현할 때는 `Comparator.comparingInt()` 메서드가 유용하다.
* 최댓값에 가까운 매우 큰 수 또는 음수를 입력값으로 허용해야 한다면, 해당 사례를 검증하는 유닛 테스트를 반드시 작성하라.
* 정렬에 관련된 코드를 테스트할 때는 최소 32개 이상의 원소가 담긴 테스트 데이터를 준비한다. 원소를 많이 추가할수록 TimSort의 불변성 위반을 포착할 가능성은 높아진다.