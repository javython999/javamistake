# 특정 반환값에 의존하는 compare()
자바 객체의 순서를 정의하는 표준 방식은 두 가지다.
`Comparble` 인터페이스를 구현(일명 자연순 방식) 하거나 커스텀 `Comparator`를 이용하는 것이다.
`Comparator.compare()`와 `Comparable.compareTo()` 메서드는 계약이 유사한 만큼 이들과 관련된 버그 패턴도 비슷하다.

다음 코드는 비교메서드의 결과를 0이 아닌 특정 상수와 비교하는 실수를 나타낸다.
```java
if (comparator.compare(a, b) == 1) {
    ... 
}
```
`compare` 메서드 중 상당수가 실제로 `-1`, `0`, `1`만 반환한다.
그러나 계약에 의하면 이들은 `1`과 `-1`뿐만 아니라 모든 양수와 음수를 반환할 수 있다.
비교자 구현이 변경되는 순간 갑자기 오작동할 위험이 있다.
비교 메서드가 `-1`, `0`, `1` 이외의 값을 반환하는 경우는 그리 드물지 않다.
특히 표준 JDK의 `String.compareTo()` 메서드는 다양한 값을 반환하는 것으로 알려져 있다.

```java
record User(String name, int age) implements Comparable<User> {
    @Override
    public int compareTo(User o) {
        int res = name.compareTo(o.name);
        return res != 0 ? res : Integer.compare(age, o.age);
    }
}
```
이 코드에서 비교 메서드는 먼저 이름으로 사용자를 정렬하고, 이름이 같으면 나이 순서로 정렬한다.

```java
    User u1 = new User("Kim", 30);
    User u2 = new User("Kim", 20);
    User u3 = new User("Park", 30);

    System.out.println(u1.compareTo(u2)); // 1
    System.out.println(u1.compareTo(u3)); // -5
```
`u1`과 `u2`는 이름이 동일하므로 비교 기능이 `Integer.compare()`로 위임되었기 때문에 `1`이다.
`Integer.compare()`는 항상 `-1`, `0`, `1`만 반환한다.
하지만 `u1`과 `u3`을 비교하면 결과는 `-5`가 된다. 이번에는 `String.compareTo()`의 결과를 반환하기 때문이다.

`compareTo()` 구현은 계약을 완변히 따르고 있으므로 아룸런 문제도 없다.
진짜 문제는 `compareTo()`의 결과를 특정한 양수와 비교하는 사용 방식이다.

이러한 문제는 예외를 거의 발생시키지 않으므로 디버깅하기 매우 어렵다.
그러나 데이터 처리 순서는 조용히 뒤바뀌고 계산 결과는 어긋날 것이다.

> 실수 방지 가이드
* 직접적이든 간접적이든, `compare()`와 `compareTo()`의 호출 결과는 `1`, `-1`처럼 `0`이 아닌 상수와 비교하지 않는다.
* 비교자용 알고리즘을 직접 만들지 않는다. 쓸만한 알고리즘은 대부분 표준 JDK 라이브러리나 유명 서드파티 라이브러리에 이미 있다.
