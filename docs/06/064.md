# 동일한 객체를 비교할 때 0을 반환하지 않음
객체를 비교할 수 있게 하려면 `compareTo()` 메서드를 구현해야 한다.
그러나 이 과정에서 인터페이스 계약을 위반하는 `comparable` 객체들이 많다.
이 시점에서 계약 규칙을 다시 정리해보자.

* 반대칭성: `x.compareTo(y)`와 `y.compareTo(x)`의 부호는 반대여야 한다. 또한 `x.compareTo(x)`는 반드시 0이어야 한다.
* 전이성: `x.compareTo(y)` > 0 이고 `y.compareTo(z)` > 0 이라면 `x.compareTo(z)`의 결과도 0보다 커야 한다.
* `x.compareTo(y) == 0` 인 경우 임의의 z에 대해 `x.compareTo(z)`와 `y.compareTo(z)`의 부호는 같아야 한다.

원본 클래스를 건드리지 않고 객체를 정렬하고 싶거나 `compareTo()` 메서드의 자연순 정렬이 불충분할 경우
`Comparator`를 직접 정의해야한다.
`Comparator`의 `compare()` 메서드는 `compareTo()`와 계약 조건이 매우 비슷하다.

* 반대칭성: `cmp.compare(x, y)`와 `cmp.compareTo(y, x)`의 부호는 반대여야 한다. 또한 `cmp.compare(x, x)`는 반드시 0이어야 한다.
* 전이성: `cmp.compare(x, y)` > 0 이고 `cmp.compare(y, z)` > 0 이라면 `cmp.compare(x, z)`의 결과도 0보다 커야 한다.
* `cmp.compare(x, y) == 0` 인 경우 임의의 z에 대해 `cmp.compare(x, z)`와 `cmp.compare(y, z)`의 부호는 같아야 한다.

`compare()`와 `compareTo()`의 중요한 차이점은, `null`에는 자연 순서가 없지만 `Comparator`는 `null`과 `non-null` 객체를 비교할 수 있다는 것이다.
`Comparator` 클래스에는 `nullsFirst()`와 `nullsLast()` 등의 정적 유틸리티 메서드가 있으며 이를 이용해 `null`을 다른 객체들의 앞이나 뒤에 배치한다.
따라서 모든 비교자는 `null`을 다룰 수 있다.

모든 기능을 직접 구현하겠다는 시도는 너무나 쉽게 계약 위반으로 이어진다.
특히 개발자는 동일한 객체를 비교하면 반드시 0을 반환해야 한다는 규칙을 종종 잊는다.

```java
class BoolObj implements Comparable<BoolObj> {
    final boolean b;
    
    BoolObj(boolean b) {
        this.b = b;
    }
    
    @Override
    public int compareTo(BoolObj o) {
        return b && !o.b ? 1 : -1;
    }
}
```
```java
BoolObj b1 = new BoolObj(true);
BoolObj b2 = new BoolObj(false);

System.out.println(b1.compareTo(b2)); // 1
System.out.println(b2.compareTo(b1)); // -1

BoolObj b3 = new BoolObj(true);
System.out.println(b1.compareTo(b3));
```
동일한 boolean 값을 래핑한 두 객체를 비교하면 -1이 반환된다.
따라서 다음과 같이 객체의 동일성 여부도 함께 확인해야한다.
```java
return b == o.b ? 0 : b ? 1 : -1;
```
이런 경우에는 라이브러리 메서드인 `Boolean.compare()`를 사용하는 편이 훨씬 안정적이다.
```java
return Boolean.compare(b, o.b);
```

> 실수 방지 가이드
* 비교 메서드를 구현할 때는 비교 대상이 서로 동일한 경우를 항상 고려한다.
당장은 아니더라도 해당 비교 메서드가 추후 다른 콘텍스트에서 재사용될 가능성이 있다.
동일한 대상의 비교 결과값을 잘못 반환하면 특정 데이터셋에 문제가 생긴다. 이러한 버그는 재현하기 어렵다.
* 객체를 자기 자신 또는 동일한 객체와 비교하는 유닛 테스트를 추가한다. 또한 그 결과가 0인지 검증한다.
* 비교 메서드에서 `boolean` 필드를 비교할 때 `Boolean.compare()`를 사용한다. 더 크다고 판단할 쪽이 어디인지에 따라 `true`, `false` 값을 인수로 교체할 수 있다.