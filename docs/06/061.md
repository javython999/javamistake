# 배열 필드 hashCode()
`hashCode()` 메서드를 구현할 때는 계약을 이행하는데 집중해야 한다.
특히 `equals()`를 실행했을 때 동일하다고 나오는 두 객체는 해시코드도 같아야 한다.

이 계약을 지키지 않은 객체를 `HashSet`과 `HashMap` 등에 넣으면 버그에 준하는 오작동이 발생한다.
이들은 모두 해시코드에 의존하는 걸렉션이기 때문이다.
`hashCode()`가 잘못되면 동일한 두 객체를 `HashSet`에 따로 넣는 것도 가능하다.

자바 7 이전에는 `hashCode()` 메서드를 수동으로 구현하기 어려웠고 에러도 자주 발생했다.
당시 이 메서드는 개별 필드의 해시코드를 구한 다음 곱셈과 덧셈을 연이어 조합하는 방식으로 구현됐다.

자바 7부터 `Objects.hash()` 메서드가 도입되고 상황은 크게 개선되었다.

```java
public int hashCode() {
    return Objects.hashCode(name, age, occupation);
}
```
이 방법은 박싱 기능 덕분에 원시 필드와 객체 필드에 모두 통용된다.
JVM이 박싱을 최적화 하지 못하면 성능 손실이 바생할 수 있지만 대체로 감수할 만하다.
그러나 가끔 `Objects.hash()`의 이러한 단순함이 문제를 일으킨다.

이 메서드는 해당 필드의 `hashCode()` 메서드에 일정 역할을 위임한다.
따라서 각각의 필드 타입에 `hashCode()`가 구현되지 않았다면 `Objects.hash()`의 결과도 그르칠 수 있다.
배열은 이 대목에서 특히 더 중요하다.
배열의 `hashCode()`는 배열의 내용을 고려하지 않으므로, 같은 내용을 지닌 배열도 해시코드가 다를 수 있기 때문이다.

```java
import java.util.Arrays;

class DataHolder {
    final int[] intData;
    final String[] stringData;

    DataHolder(int[] intData, String[] stringData) {
        this.intData = intData;
        this.stringData = stringData;
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        DataHolder dh = (DataHolder) o;
        return Arrays.equals(intData, dh.intData)
                && Arrays.equals(stringData, dh.stringData);
    }
    
    public int hashCode() {
        return Objects.hash(intData, stringData);
    }
}
```

이 코드는 동일한 객체를 두 개 만들고 특정한 HashSet에 추가한다.
그러나 중복이 제거되지 않고 모두 추가된다.

굳이 `Objects.hash()`를 사용하고 싶다면 다음과 같이 배열을 `Arrays.hashCode()` 호출로 래핑하면 된다.

```java
public int hashCode() {
    //return Objects.hash(intData, stringData);
    return Objects.hash(
            Arrays.hashCode(intData),
            Arrays.hashCode(stringData)
    );
}
```
이렇게 하면 배열은 물론 배열이 아닌 필드도 함께 `Objects.hash()`에 넣을 수 있다.
또한 수학적 연산 코드를 직접 코딩할 필요도 없다.
다차원 배열일 경우 `Arrays.deepHashCode()`, `Arrays.deepEquals()`를 사용하면 된다.

자바 레코드도 주의할 점이 있다.
레코드의 `hashCode()`와 `equals()` 메서드는 자동으로 구현 되지만  그 곳에서 배열을 별도로 처리하지 않는다.
따라서 배열 레코드 컴포넌트는 내용이 아닌 참조 방식으로 비교 된다.
배열의 내용을 비교하려면 `hashCode()`, `equals()`를 수동으로 구현해야 한다.

> 실수 방지 가이드 
* `equals()`와 마찬가지로, `hashCode()`는 수동으로 구현하지 않는다. IDE를 통해 이 메서드를 구현하라.
IDE는 배열을 특별하게 처리해야 한다는 것을 알고 있으므로 단순히 `Objects.hash()`로 래핑하고 끝내지 않는다.

* 자바 레코드에서 배열 컴포넌트는 신중하게 사용한다.
가능하면 List를 사용하는 것이 좋다. List 구현체는 리스트의 내용을 기반으로 해시코드를 계산한다.
자바는 아직 List<int>를 사용할 수 없으며 List<Integer>를 사용하면 성능과 메모리 면에서 오버헤드가 생긴다.
레코드 컴포넌트는 '원시 배열'을 사용해야 할 때는 `equals()`와 `hashCode()`를 명시적으로 구현하는 것이 합리적인 선택이다.