# 우발적인 정적 필드 선언
간혹 인스턴스 필드를 선언하며 실수로 `static`을 붙이는 경우가 있다.
이러한 실수는 주로 리팩터링이나 복사-붙여넣기 과정에서 발생하며, 하나의 필드 인스턴스가 해당 클래스의 모든 객체 사이에 공유되는 결과를 낳는다.

```java
class Person {
    private static String name;
    
    public void setName(String newName) {
        name = newName;
    }
    
    public String getName() {
        return name;
    }
}
```
객체가 동시에 두 개 이상 존재하지 않는 한 프로그램은 제대로 작동할 것이다.
그러나 사용자가 늘어나면 복수의 객체가 동시에 세션을 공유할 가능성도 커진다.

정적 필드를 `final`로 전환해도 문제는 완전히 해결되지 않는다.
정적 final 필드에 저장된 객체가 내부적으로 변경될 수 있기 때문이다.
필드에 컬렉션이 있으면 이를 직접 재할당하지 않더라도 데이터는 계속 객체 사이에서 공유된다.

```java
interface TreeNode {
    List<TreeNode> getChildren();
}
```

```java
import java.util.ArrayDeque;

class TreeWalker {
    private static final Queue<TreeNode> toProcess = new ArrayDeque<>();
    
    TreeWalker(TreeNode root) {
        toProcess.add(root);
    }
    
    TreeNode nextNode() {
        TreeNode next = toProcess.poll();
        if (next != null) {
            toProcess.addAll(next.getChildren());
        }
        return next;
    }
}
```
두 개의 TreeWalker 객체가 서로 다른 스레드에서 생성되면 양쪽의 트리 노드가 뒤섞이게 된다.

> 실수 방지 가이드 

* final이 안니 정적 필드 선언은 지양한다. 이러한 필드는 매우 특수한 상황에서만 사용하고 IDE가 명확하게 강조 표시할 수 있도록 설정해야 한다.
* 비정적 콘텍스트에서 정적 필드가 갱신되면 경고가 발생하도록 정적 분석 도구를 설정한다. 아무 문제가 없는 경우도 더러 있지만 경계를 늦추면 안된다. 멀티스레드 프로그램에서 이러한 경고가 발생하면 실제로 문제가 있을 가능성이 높다.
* 가변 객체를 정적 필드에 저장하지 않는다. 변경 가능 여부를 정확히 모를 때는 클래스 설명서를 확인한다.
* 스레드 안전을 고려할 필요가 없을 때는 스레드 안전 가변 객체를 쓰지 않는다.스레드 안전 객체는 성능 오버헤드를 추가한다. 또한 의도치 않게 여러 스레드에서 동시에 공유되어도 즉시 문제가 드러나지 않을 가능성이 있다.
* 특정 객체를 여러 스레드에서 사용할 때는 통합 테스트를 이용해 해당 상황을 재현해본다.