# assert 문의 부수효과
본격적으로 유닛 테스트를 논하기 앞서 `assert` 문을 고찰해보자.
이 구문들은 자바 코드에서 항상 참이어야 하는 불변 조건을 확인할 때 사용한다.
이 기능은 주로 테스트 환경이나 스테이징 환경(JVM의 -ea(enable assertions) 옵션)에서 실행하며 프로덕션 환경에서는 무시한다.
`assert` 문에서 문제가 생기는 가장 흔한 사례는 `assert` 내부에서 표현식이 부수 효과를 일으킬 때다.
예를 들어 다음 `assert` 문은 실수일 가능성이 크다.

```java
assert.set.add(value) : "set already contains " + value;
```
이 코드에서 set.add(value) 표현식은 어설션이 꺼져있는 환경에서 실행되지 않으므로 세트에 원소가 추가되지 않는다.
이 코드는 다음 코드와 본질적으로 동일하다.
```java
if (assertionsEnabled) {
    if (!set.add(value)) {
        throw new AssertionError("set already contains " + value);    
    }
}
```
이 버그는 다음과 같이 표현식을 별도의 로컬 변수로 추출하면 해결된다.
```java
boolean added = set.add(value);
assert added : "set already contains " + value;
```
다음은 프로덕션 코드에서 실제로 발생했던 또 다른 사례다.
```java
static int extractNumber(String message) {
    Pattern pattern = Pattern.compile("\\((\\d+)\\)");
    Matcher matcher = pattern.matcher(message);
    assert matcher.find();
    return Integer.parseInt(matcher.group(1));
}
```
이 코드의 작성자는 입력 문자열 안에서 괄호로 묶인 숫자를 찾아내고자 했다.
또한 그러한 숫자가 항상 존재해야 한다고 선언했다.
그러나 `matcher.find()`는 그룹을 채우는 부수효과를 동반한다.
만일 이 코드를 -ea 옵션 없이 실행하면 다음 줄의 `matcher.group(1)` 호출은 실패할 것이다.

어설션 기능의 부작용은 테스트 환경에서만 작동하는 코드가 생긴다는 점이다.
이러한 버그는 테스트 커버리지를 100% 달성해도 끝까지 발견되지 않는다.
결국 그 프로그램은 프로덕션에 가서야 고장 날 것이다.

> 실수 방지 가이드
* 가끔은 지속적 통합 단계에서 어설션 비활성화 상태로 세트를 실행한다. 활성화 전과후의 프로그램 작동 결과를 비교하고 둘이 동일한지 확인한다.
* assert 문을 남용하지 않는다. 이번 절의 matcher 예시에서 숫자가 검색되지 않는다면 그 원인은 불변 조건의 문제가 아닌 사전 조건의 문제일 가능성이 크다.
따라서 다음과 같이 assert 대신 if 문을 사용하는 것이 더 바람직하다.
```java
if (!matcher.find()) {
    throw new IllegalArgumentException(message + " must include (number)");    
}
```