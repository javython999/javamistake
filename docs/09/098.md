# 유닛 테스트에서 AssertionError 무시하기
유닛 테스트의 메커니즘은 간단하다.
예상치 못한 일이 생기면 `AssertionError`를 던지고 테스트 프레임워크는 이를 포착한 다음 테스트 실패 정보를 출력한다.
이 설명은 중대한 함의를 담고 있는데, `assertionEquals()` 등의 메서드가 `AssertionError`를 던지는 것이 전체 메커니즘의 일부에 불과하다는 점이다.
이러한 예외를 테스트 메서드 호출자에게 전달하는 것 또한 필수적인 과정이다.
이 대목에서 발생하는 잠재적인 실수는 테스트 중에 지나치게 광범위한 예외를 포착하는 것이다.
가령, 특정 계산 결과를 확인하는 테스트가 있다고 가정해보자.
이러한 테스트에서 예외를 대수롭지 않게 취급하면 다음과 비슷한 코드가 나온다.

```java
public void testFileProcessing() {
    try {
        List<String> input = Files.readAllLines(Path.of("input.txt"));
        List<String> expected = Files.readAllLines(Path.of("output.txt"));
        assertEquals(expected, processInput(input));
    } catch (Exception e) {
        
    }
}
```
물론 이 코드는 전체적으로 엉성하게 만들어진 유닛 테스트다.
그러나 가장 큰 문제는 `assertEquals()`가 실패하면 `AssertionError`가 무시되고 테스트 프레임워크가 테스트 실패를 감지하지 못한다는 점이다.

```java
public void testComputation() throws InterruptedException {
    Thread thread = new Thread(() -> {
       assertEquals("Expected", computeSomething()); 
    });
    thread.start();
    thread.join();
}
```
이 코드에서 어설션이 실패하면 별도의 스레드에서 `AssertionError`를 던진다. 이 예외는 미처리 예외 핸들러가 포작하고 표준 에러 스트림으로 예외 정보를 출력한다.
하지만 이 예외는 테스트가 시작됐던 원래의 스레드로 전달되지 않으며, 결국 테스트 프레임워크는 이 테스트가 성공했다고 판단한다.
누군가 에러 로그를 확인하지 않는 한 예외 발생 사실은 들어나지 않을 것이다.
필자는 이런 유형의 실수를 여러 번 봤지만 재현하기는 쉽지 않다.
스레드를 설정하고 결과를 수집하는 과정은 일반적으로 대량의 코드가 관여하기 때문이다.
그나마 단순했던 사례는 `OkHttp` 프로젝트에서 발견했던 실수였다.
해당 테스트는 미완성 상태로 폐기된 것으로 보이며 코드는 다음과 비슷했다.

```java
import java.util.concurrent.ExecutorService;

ExecutorService executor = Executors.newCachedThreadPool();
CountDownLatch latch = CountDownLatch(2);
executor.execute(new AsyncRequest("/r1", latch));
executor.execute(new AsyncRequest("/r2", latch));
countDownLatch.await();
```

> 실수 방지 가이드
* `Throwable`처럼 광범위한 예외를 유닛 테스트에 적용하지 않는다. 테스트뿐만 아니라 일반 코드도 마찬가지다.
예외 감지 범위가 지나치게 넓으면 중요한 문제를 지나치기 쉽다. 또한 프로덕션 코드에서 문제가 발생했을 때 원인을 조사하기도 어렵다.
예외를 무시하려면 무시할 예외를 정확하게 특정해야 한다.
* try 블록 안에서 어설션을 사용할 때는 주의해야 한다.
* 병렬 연산이 필요할 때는 기본 스레드가 아닌 `java.util.concurrent` API의 `ExecutorService`, `ForkJoinPool` 등을 쓰는 것이 좋다.
또한 `CountDownLatch` 같은 사이드 동기화 메커니즘보다 `Future` 또는 `CompletableFuture`로 병렬 연산을 합치는 것이 좋다. `Future`는 예외를 전달하기 때문이다.
* 가능한 한 모든 어설션을 원래의 스레드 안에 둔다. 또한 `Arragne`, `Act`, `Assert` 패턴을 따른다.
이 패턴을 따르면 검증은 실행 단계 이후에 수행된다. 벙렬 연산과 결과는 원래의 스레드에 모두 수집하고 최종 결과를 검증하는 것이 좋다.