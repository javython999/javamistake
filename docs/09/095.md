# 잘못된 assertion 메서드 호출
유닛 테스트를 실행하려면 `JUnit`이나 `TestNG` 등의 테스트 프레임워크가 필요하다.
따라서 테스트 클래스와 메서드는 해당 프레임워크의 규칙에 맞게 만들어야 한다.
이러한 규칙은 일반적으로 세 가지 절차로 구성된다.

* 배치(arrange): 테스트 실행 환경을 준비하는 코드. 주로 이곳에서 헬퍼 객체를 생성하고 설정한다. 간단한 테스트에서는 생략되기도 한다.
* 실행(act): 테스트 대상 함수나 메서드를 실행한다.
* 검사(assert): 함수나 메서드가 예상 결과를 반환하는지 확인한다.

일명 `AAA`로 불리는 이 패턴은 수많은 함정으로 개발자를 보호해왔다.
이 구조를 따르지 않는 테스트는 가급적 지양하는 것이 좋다.

테스트도 일종의 코드이므로 단계마다 실수가 생기곤 한다.
실수로 인해 테스트가 실패하면 보통은 원인을 바로 찾아낼 수 있으므로 큰 문제가 되지 않는다.
그러나 실수로 인해 테스트가 아무것도 검증하지 않고 하상 성공하면 문제가 훨씬 더 커진다.
심지어 테스트 대상 함수가 실제 잘못 작동하고 있어도 이를 감지할 수 없다.

이러한 실수는 대부분 검사 단계에서 발생한다.
어설션 코드는 assert로 시작하는 다양한 메서드 중 하나를 호출하며 시작된다.
가령 `JUnit`에서 `assertTrue()`는 인수가 참인지 확인하고 `assertEquals()`는 두 인수가 서로 같은지 확인한다. 이처럼 메서드명이 비슷한 실수로 엉뚱한 메서드를 호출하기도 쉽다.

예를 들면 `assertTrue()` 또는 `assertFalse()` 대신 다음과 같이 `assertNotNull()`을 쓰는 실수도 자주 발생한다.
```java
assertNotNull(data.isEmpty());
```
이 코드에서 `isEmpty()` 메서드는 불리언 값을 반환하며, 어설션 함수에 전달되는 과정에서 Boolean 객체로 박싱된다.
물론 이 객체는 절대 null이 되는 경우가 없으므로 이 테스트는 `isEmpty()` 메서드의 결과와 상관없이 항상 성공하게 된다.
박싱 변환은 자동으로 진행되며 컴파일러는 이를 경고하지 않는다.

어셜션 메서드의 파라미터를 누락하는 실수도 종종 발생한다.
`JUnit`을 비롯한 대부분의 테스트 프레임워크는 어설션 메서드에 생략 가능한 파라미터가 있다.
예를 들어 `JUnit 4`는 `assertNotNull(object)`와 `assertNotNull(message, object)`를 모두 사용할 수 있다.
`message` 파라미터 하나만 전달해도 컴파일을 되지만 message는 object로 해석된다.
`message`에 null을 전달하는 경우는 거의 없으므로 이러한 assert는 항상 성공한다.

> 실수 방지 가이드
* `assertNotNull()` 및 `assertNotEquals()` 메서드에 전적으로 의존하지 않는 것이 좋다.
이 조언의 의의는 이번 절의 사례에 국한되지 않는다. 일반적으로 이러한 유형의 메서드는 검사 대상이 특정 값이 아니라는 사실만 확인할 뿐이다.
무엇이 아닌지 확인하는 약한 검사보다는 무엇이 맞는지 보장하는 엄격한 어셜션이 훨씬 효과적이다.
* 테스트는 항상 실패에서 시작해야 한다. 테스트 주도 개발(TDD) 방법론은 실제 코드보다 테스트를 먼저 작성하도록 제안한다. 이 규칙을 엄격히 따르면 프로덕션 코드가 작동하는 것보다
테스트가 실패하는 것을 먼저 볼 수밖에 없다. 어떤 코드는 무조건 통과시키는 잘못된 어설션이 있다면 시작 단계에서 즉각 발견될 것이다.