# 잘못된 예외 테스트
특정 예외의 발생 여부를 유닛 테스트에서 확인해야 할 때가 종종 있다.
과거에는 이를 간단히 처리할 방법이 없어서 다음과 같은 패턴으로 코드를 구현하곤 했다.
```java
@Test
public void ensureException() {
    try {
        doSomething();
        fail("No exception was thrown");
    } catch (MyException ex) {
        assertEqausls("Expected exception message", ex.getMesage());
    }
}
```
이러한 방식의 문제는 코드가 상당히 장황하며 중간에 어긋나기 쉽다는 것이다.
가장 흔한 실수는 다음과 같이 fail()을 빼먹는 것이다.
```java
@Test
public void ensureException() {
    try {
        doSomething();
    } catch (MyException ex) {
        assertEqausls("Expected exception message", ex.getMesage());
    }
}
```
이 코드는 언뜻 보면 올바른 테스트 같다. 예외가 발생했을 때 예외 메시지나 예외 타입이 일치하지 않으면 예상대로 실패할 것이다.
그러나 `doSomething()`이 예외를 던지지 않고 정상적으로 작동하기 시작하면 이 테스트는 문제를 감지하지 못한다.

`JUnit 4`는 `@Test` 어노테이션의 `expected` 파라미터를 통해 예상 예외를 전달할 수 있다.
따라서 다음과 같이 더 간결하고 실수할 위험도 덜한 테스트를 작성할 수 있다.

```java
@Test(expected = MyException.class)
public void ensureException() {
    doSomething();
}
```
그러나 이 방식으로 예외 메시지를 테스트할 수는 없다.
대안으로 `JUnit 5`에 도입된 `assertThrows()` 메서드를 사용하면 예외 메시지뿐만 아니라 더욱 다양한 방법으로 예외를 테스트 할 수 있다.
```java
@Test
public void ensureException() {
    MyException ex = assertThrows(MyException.class,  () -> doSomething());
    assertEquals("Expected exception message", ex.getMessage());
}
```
이 코드에서 `assertThrows()`는 특정 타입의 예외가 발생하는지 확인하고 해당 예외를 반환한다.
따라서 예외 메시지 등의 각종 결과를 검증할 수 있다.

> 실수 방지 가이드
* 최신 버전의 테스트 프레임워크와 `assertThrows()` 등의 신형 메서드를 활용한다.
* 테스트 프레임워크를 업데이트할 수 없거나 용도에 부합하는 테스트 메서드가 없다면 `assertThrows()`처럼 유연한 헬퍼 메서드를 직접 만들고 모든 곳엥서 재사용하라.