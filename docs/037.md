# 비트 조작 알고리즘
숫자를 양이 아닌 비트 벡터로 취급하고 각각의 비트를 비트 연산자나 비트 시프트 연산으로 조작하는 경우가 있다.
이러한 조작 방식을 `비트 트위들링`이라 한다.
비트 트위들링은 여러 값을 하나의 숫자로 패킹할 때 쓸모가 많다.

비트 연산은 간단해 보이지만 그만큼 착각하기도 쉽다.
단순한 알고리즘일수록 코너 케이스를 주의해야 한다.

```java
int value;

void applyMask(int keepBit) {
    value &= (1 << keepBit) - 1;
}
```
지정한 자릿수만큼 특정 숫자의 하위 비트를 보존하거 나머지는 제거하는 것이다.
이 코드는 keepBit가 0에서 31사이일 때 정상적으로 작동한다.
keepBit가 32일 때 value의 모든 비트가 유지되고 결과적으로 메서드가 아무 일도 하지 않을 것이라 예상 했다.
하지만 실제로 `1 << 32`는 `1 << 0`과 동일하게 평가되며 결과적으로 1이 된다.
비트 시프트 연산을 수행할 때 자바는 먼저 시프트할 폭을 결정한다.
이를 위해 int 타입은 32로, long 타입은 64로 입력값을 나누고 나머지를 구한다.
32를 32로 나눈 나머지는 0이므로 시프트는 방생하지 않고,
1에서 1을 뺀 결과는 0이 된다.
결국 아무일도 하지 않았어야 할 이 메서드는 value를 0으로 바꾸고 일부 애플리케이션에서 오작동을 일으킬 것이다.

> 실수 방지 가이드
* 비트 연산을 남발하며 코드를 어지럽히지 않는다. 이러한 연산은 유틸리티 메서드로 추출하고 격리시킨 다음 꼼꼼한 테스트를 거쳐 재사용한다.
* long 값으로 비트 연산을 할 때에는 상위 비트를 검증하는 유닛 테스트를 작성한다.
* 코너 케이스를 항상 염두에 두고 경계값 입력을 검증하는 유닛 테스트를 작성한다.
* 비트 연산 알고리즘을 직접 고안하지 않는다.
* 여러 값을 꼭 하나의 숫자로 패킹할 필요가 있는지 재고한다. 그보다는 라이브러리 클래스를 먼저 고려한다. BitSet 클래스는 비트 문자열을 더 편리하게 표현하고 모든 종류의 입력을 처리하며, 메서드마다 역할이 명확하게 드러낸다.
또 비트 수를 32나 64로 제한하지 않는다. 향후 더 많은 비트를 다루게 되어도 기존 코드를 크게 고칠 필요가 없다.
* 여러 개의 플래그를 다룰 때는 플래그 목록을 열거형으로 선언하고 EnumSet으로 처리한다. 추가 비용은 거의 들지 않으면서 코드는 훨씬 더 명확하고 견고해진다.