# 조건 표현식의 묵시적 타입 변환
조건 표현식 또는 삼항 연산자는 if 문과 매우 비슷하다.
많은 개발자들이 if 문과 완전히 동일하다고 여긴다.
대부분의 경우는 타당하지만, 숫자를 다룰 때는 그렇지 않다.

## 조건 표현식의 박싱된 숫자
```java
public Double valueOrZero(double condition, Double value) {
    return condition ? value : 0.0;
}
```
condition이 참일 때 인수를 변경하지 않고 그대로 반환하는 것 처럼 보인다.
조건 표현식의 최종 결과 타입을 결정하는 절차는 꽤 복잡하다.
 스펙을 모두 숙지하기는 어렵겠지만 몇 가지 기본원리들을 기억해두면 좋다.

1. 자바에느 독립형 표현식과 다형성 표현식이 있다.   
독립형 타입은 주변 컨텍스트와 무관하게 표현식 자체가 정의한다. `a + b`는 독립형 표현식이며 a와 b의 타입을 알면 항상 전제 표현식의 타입을 판단할 수 있다.    
반면 `Collections.emptyList()`는 다형성 표현식이다. 이 표현식은 타입은 주변 컨텍스트에 따라 List<Integer>, List<String> 등의 다양한 List로 결정된다.
원시 타입 또는 원시 래퍼를 취급하는 조건 표현식은 무조건 독립형 표현식이므로 주변 컨텍스트는 결과 타입에 영향을 주지 않는다.
예시에서 메서드 반환 타입이 Double이라는 사실은 표현식 타입과 아무런 관련이 없다.
타입을 결정하는 것은 `condition ? value : 0.0`이라는 표현식 자체다.

2. then 표현식에서 Integer나 Double 등의 박싱된 타입이 있고 else 표현식에는 int나 double 등의 원시 타입이 있으면(혹은 그 반대의 경우) 원시타입이 우선시 된다는 점이다.
따라서 `condition ? value : 0.0`의 결과 타입은 원시 double이다.
예시 메서드는 조건 표현식을 실행한 다음 결과를 다시 박싱한다. 자바는 원시 타입을 박싱 타입으로 변환할 때 `valueOf()`등의 정적 메서드를 묵시적으로 호출하며 언박싱 변환할때는 `doubleValue()` 등의 인스턴스 메서드를 호출한다.

예시 코드의 문제는 상당히 명확해 졌다.
1. value는 항상 박싱되며 그 외에 두 개의 박싱된 값이 있으므로 불필요하게 메모리를 낭비할 위험이 있다.
2. valueOrZero(ture, null)을 호출하면 어떻게 될까? 묵시적으로 value.doubleValue() 메서드가 호출되므로 NullPointerException이 발생한다.

> 실수 방지 가이드

* 박싱된 원시 타입을 사용하지 않는다. 가끔 제네릭 타입을 다룰 때는 필요하지만 가능한 한 빨리 원시 값으로 변환하는 것이 좋다.
이렇게 하면 해당 변수가 null이 될 수 없음을 명확히 선언하는 효과도 생긴다.
* 박싱된 타입이 꼭 필요한 경우에는 조건 표현식이 아닌 if 문을 쓴다. 코드는 더 장황해 보일지라도 혼란은 덜하다.
* 숫자로 이루어진 조건 표현식은 독립형 표현식이므로 주변 컨텍스트가 타입에 영향을 미치지 않는다는 점을 유념한다.

## 중첩 조건 표현식
중첩 조건 표현식에 박싱된 원시 타입을 쓰는 경우도 예상치 못한 결과가 발생할 수 있다.
```java
static Integer mapValue(int input) {
    return input > 20 
            ? 2
            : input > 10 
                ? 1
                : null;
}
```
이 메서드는 박싱된 Integer를 반환하므로 2, 1, null 모두 유효하다.
그러나 10 이하인 input 값으로 메서드를 호출하면 NullPointerException이 발생한다.
더 흥미로운 점은 다음과 같이 조건 순서를 변경하면 제대로 동작한다는 것이다.

```java
static Integer mapValue(int input) {
    return input <= 10 
            ? null
            : input <= 20 
                ? 1
                : 2;
}
```

원시 타입인 int가 null을 만나면 결과 타입인 Integer처럼 박싱된 타입이 된다.
```java
static Integer mapValue(int input) {
    return Integer.valueOf(
            input > 20 
                    ? 2 
                    : (input > 10 ? Ineteger.valueOf(1) : null).intValue());
}
```

두 번째 코드는 더 간단하다. 다음과 같이 한 개의 묵시적 자동 박싱 변환만 있다.

```java
static Integer mapValue(int input) {
    return input <= 10 
            ? null
            : Integer.valueOf(input <= 20 ? 1 : 2);
}
```

> 실수 방지 가이드

* 중첩 조건 표현식을 지양하고 if문을 사용한다.
* 분기에 따라 다른 타입을 반환하는 조건 표현식은 쓰지 않는다. 하나 이상의 분기에 원시 타입이 있을 경우 특히 위험하다. 자동 탕비 변환은 가끔 직관에 반하는 결과를 낸다.