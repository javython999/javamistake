# 잘못된 가변 인수 호출
자바 1.5부터 메서드 파라미터 중 마지막 요소를 `가변 인수`로 선언할 수 있다.
이렇게 전달한 모든 인수는 배열로 자동 래핑된다.
가변인수는 편리한 기능임에 틀림없지만 다양한 실수의 원천이기도 하다.

## 모호한 가변 인수 호출
```java
static void printAll(Object... data) {
    for (Object d : data) {
        System.out.println(d);
    }
}
```
이 메서드를 다음과 같이 두가지 방식으로 호출해도 결과는 동일하다.

```java
printAll("Hello", "World");
printAll(Object[]{"Hello", "World"});
```

그러나 이러한 편의에는 대가가 따른다.
정확히 하나의 인수를 전달했을 때, 이 인수가 배열로 래핑될 것인지 즉각적으로 알기 어려워진다.
```java
printAll(obj);
```
이 코드에서 obj의 배열 래핑 여부는 obj의 타입에 의해 결정된다.
obj가 비원시 타입일 경우 래핑되지 않는다.
더 중요한 점은 이러한 결정이 런타임 타입이 아닌 선언 타입에 따라 이루어진다는 것이다.

```java
Object obj = new Object[]{"Hello", "World"};
printAll(obj);
```
컴파일러는 obj의에 담긴 객체의 실제 타입을 알지 못한다.
따라서 컴파일러는 이 배열을 또 다른 배열로 래핑하기로 결정한다.

```java
printAll(null);
```
하나의 null을 전달 했으니 배열로 래핑되고 결과적으로 null 문자열이 출력될 것이라 예상하기 쉽다.
자바 언어 스펙에 따르면 가변 인수 메서드에 전달한 값이 해당 메서드의 인수 타입 배열에 할당 가능한 값일 경우, 이를 배열로 래핑하지 않는다.
null은 모든 종류의 배열 변수에 할당할 수 있으므로 절대 래핑되지 않는다.
결국 printAll 메서드의 data 파라미터에 null을 할당하며 NullPointerException이 발생하게 된다.

> 실수 방지 가이드

* 가변 인수 파라미터에 인수를 하나만 전달할 때는 신중을 기한다. 어떻게 처리될지 확실치 않을 경우에는 다음과 같이 명시적으로 타입을 캐스팅한다.
```java
printAll((Object) null);

printAll((Object[]) null);
```

* 가급적이면 null 인수를 쓰지 않는다. 특히 배열과 가변 인수 메서드를 다룰 때는 더욱 자제하는 것이 좋다.


## 배열과 컬렉션 혼용
가변 인수 메서드에 배열 대신 컬렉션을 전다랗면 또 다른 문제가 발생한다.
다음과 같이 배열에 특정 원소가 포함되어 있는지 확인하는 유틸리티 메서드가 있다고 가정해보자.
```java
@SafeVarargs
static <T> boolean contains(T needle, T... haystack) {
    for (T t : haystack) {
        if (Objects.equals(t, needle)) {
            return true;
        }
        return false;
    }
}
```

```java
static final List<String> allLanguages = List.of("Java", "Groovy", "Scala", "Kotlin");

static boolean isLanguage(String language) {
    return contains(language, allLanguages);
}
```
배열과 컬렉션이 의미적으로 비슷한 탓에 개발자는 allLanguages가 배열이라고 착각했는지도 모른다.
`contains(language, allLanguages)`라는 호출코드는 컴파일러 에러를 일으키지 않는다.
컴파일러는 타입 파라미터 T를 Object로 추론하고 해당 컬렉션을 단원소(Single-element) 배열로 래핑한다.
따라서 `contains()` 메서드는 컴파일러 에러 없이 무조건 `false`를 반환하게 된다.

> 실수 방지 가이드

* 배열 변수 타입을 컬렉션으로 변경할 때는 주의를 기울여야 한다. 컴파일러 에러가 발생할 뿐만 아니라 기존 변수를 사용했던 모든 곳을 확인해야 한다. 컴파일러 에러가 없더라도 코드의 의미가 변경됐을 가능성이 있다.
* 반환 타입이 boolean인 메서드를 호출할 때는 참과 거짓을 확인하는 테스트를 모두 작성한다. 이렇게 하면 테스트 코드가 항상 같은 값을 반환하고 있는지 바로 알 수 있다.

## 가변인수에 원시 배열 전달
`Arrays.asList()` 메서드도 비슷한 문제를 일으킬 수 있다.
이 메서드는 배열과 컬렉션을 오가는 가교 역할을 한다.

```java
Arrays.asList(arr).contains("Hello");
```

문자열 배열 arr에 "Hello"가 포함되어있ㄴ느지 확인하는 표현식이다.
그러나 이 코드에 원시 배열(primitive array)를 넣으면 제대로 동작하지 않는다.

```java
static boolean containsZero(int[] arr) {
    return Arrays.asList(arr).contains(0);
}
```
이 메서드는 정상적으로 컴파일되지만 배열의 내용과 상관없이 항상 false를 반환한다.
`asList()` 메서드 선언부는 다음과 같다.
```java
public static <T> List<T> asList(T... a) {...}
```
파라미터 타입 T는 비원시 타입으로만 대체되므로 원시 타입 배열은 T[] 타입에 할당되지 않는다.
T가 int[]일 경우 컴파일러는 이를 단원소 배열로 래핑하며 입력 배열을 담은 List<int[]>를 생성한다.

이 하나의 원소는 숫자 0과 비교할 수 없다.
또한 여기에서 숫자 0은 자동으로 Integer로 박싱된다.

> 실수 방지 가이드
* Arrays.asList() 메서드에 원시 배열을 전달하지 않는다.
* 다음과 같이 명시적으로 타입이 선언된 중간 변수를 둔다.
```java
static boolean containZero(int[] arr) {
    List<int[]> list = Arrays.asList(arr);
    return list.contains(0);
}
```