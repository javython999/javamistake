# 조건식의 괄호 누락

## &&, ||의 우선순위
컴파일러가 조건식의 모든 문제를 감지하지는 못한다.
비트 연산자 &, |와 비슷하게 논리 연산자 &&는 ||보다 우선순위가 높다.

```java
if (index >= 0 && str.charAt(index) == ' ' || str.charAt(index) == '\t') {
    ...
}
```

* 프로그래머가 의도한 연산 순서
  * index >= 0 && ( str.charAt(index) == ' ' || str.charAt(index) == '\t' )
* 컴파일러가 이해한 연산 순서
  * (index >= 0 && str.charAt(index) == ' ') || str.charAt(index) == '\t'

> 실수 방지 가이드

* &&와 || 연산자가 모두 있는 조건식은 각별히 신중하게 취급한다. 우선순위가 미심쩍은 부분이 있으면 자바 연산자 우선순위 표를 참고한다.
* 가급적이면 && 및 || 연산자가 단일 표현식에 등장할 때마다 괄호로 묶는다.
* 복작한 조건식은 if 문을 작성하고 더 간단한 조건식으로 분할한다.

```java
if (index >= 0) {
    if (str.charAt(index) == ' ' || str.charAt(index) == '\t') {
        ...    
    }    
}
```
그러나 이러한 중첩 if문은 SonarQube에서 `Collapsible if statements should be merged`라는 경고를 일으킨다.
합칠 수 있는 if 문은 축약해야 한다는 뜻이다. 저자는 이 규칙을 비활성화 하는 것이 상책이라고 표현했다.

* 복잡한 조건식은 일부만 떼어 별도의 메서드로 추출해본다.
```java
static boolean isWhitespace(char ch) {
    return ch == ' ' || ch == '\t';
}
```
```java
if (index >= 0 && isWhitespace(str.charAt(index))) {
    ...
}
```
* 복잡한 조건식이 있을 때는 유닛 테스트 커버리지에 주의를 기울인다. true와 false 결과를 모두 테스트 하고 있는지 확인한다.

## 조건 연산자와 덧셈
삼항 연산자라고도 불리는 조건 연산자(?:)는 우선순위가 가장 낮은 축에 든다.
조건 연산자의 우선순위는 종종 성가신 문제를 일으키곤 하지만 대부분은 컴파일러에서 쉽게 감지할 수 있다.
그러나 다음은 유효한 자바 코드이며 컴파일러는 아무런 문제도 발견할 수 없다.
```java
static String indentString(String str, int indent) {
    int capacity = str.length() + indent < 0 
            ? 0 
            : indent;
    StringBuilder sb = new StringBuilder(capacity);
    for (int i = 0; i < indent; i++) {
        sb.append(' ');
    }
    sb.append(str);
    return sb.toString();
}
```

* 프로그래머가 의도한 연산 순서
  * str.length() + (indent < 0 ? 0 : indent)
* 컴파일러가 이해한 연산 순서
  * (str.length() + indent < 0) ? 0 : indent

> 실수 방지 가이드

* 조건 표현식이 복잡한 표현식의 일부일 때는 항상 괄호로 묶는다. 그 부분의 우선순위가 가장 낮을 가능성이 크기 때문이다.
* 이번 예시는 다음과 같이 라이브러리 메서드로 최대값을 계산하면 문제를 예방할 수 있다.
```java
int capacity = str.length() + Math.max(indent, 0);
```
* 동일한 문자를 반복시켜 새로운 문자열을 만들 때는 코드를 직접 구현하지 않는다. 자바 11부터 String 클래스에 `repeat()`메서드를 사용할 수 있다.
```java
static String indentString(String str, int indent) {
    if (indent < 0) {
        return str;
    }
    return " ".repeat(indent) + str; 
}
```

## 조건 연산자와 null 검사
조건 연산자가 문자열 결합 구문 뒤에 올 때도 비슷한 문제가 발생한다.
```java
String format(String value) {
    return "Value: " + value != null
            ? value
            : "(unknown)";
}
```

* 프로그래머가 의도한 연산 순서
  * "Value " + (value != null ? value : "(unknown)")
* 컴파일러가 이해한 연산 순서
  * ("Value " + value) != null ? value : "(unknown)"

> 실수 방지 가이드

* 서로 다른 연산자가 포함된 복잡한 표현식은 다음과 같이 중간 변수를 이용해 분할한다.
```java
String displayedValue = value != null 
        ? value 
        : "(unknown)";
return "Value: " + displayedValue;
```
* 문자열을 직접 결합하는 대신 다음과 같이 포매팅 메서드를 호출한다.
```java
return String.format("Value %s", value != null ? value : "(unknown)");
```
* 자바 15부터는 다음과 같은 방식으로 작성할 수 있다.
```java
return "Value %s".formatted(value != null ? value : "(unknown)");
```
* 자바 9부터는 `Objects.requireNonNullElse()` API 메서드로 null 판단 조건 표현식을 대체할 수 있다.
```java
return "Value: " + requireNonNullElse(value, "(unknown)");
```