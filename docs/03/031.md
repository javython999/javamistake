# 확장으로 인한 정밀도 손실
원시 타입 확장은 기본 타입의 값이 다른 타입으로 변환되는 과정을 일컫는다.
이때 통상적으로 타입 범위는 넓어지며 값은 유지된다.
문제는 모든 경우에 그렇지는 않다는 것이다.
확장은 산술 연산, 할당, 메서드 반환, 메서드 인수 전달 시 묵시적으로 발생하므로 문제가 겉으로 드러나지 않는다.

정밀도 손실이 발생하는 세 가지 확장 변환은 `int -> float`, `long -> float`, `long -> double`이다.

```java
long longVal = 1L << 53;
double doubleVal = longVal;
double doubleValPlusOne = longVal + 1;

System.out.println(doubleVal == doubleValPlusOne); // true
```

> 실수 방지 가이드

* 반드시 float 타입을 요구할 정도로 성능이 우선시되지 않는 한 float 타입은 쓰지 않는다. 이렇게 하면 `int -> float`과 `long -> float` 확장 변환 문제를 배제할 수 있으므로 약 10^15까지 안심하고 숫자를 다룰 수 있다.
* 부동소수점 타입이 묵시적으로 확장되지 않도록 한다. 다음과 같이 명시적으로 타입 캐스트를 추가하고, 보는 사람으로 하여금 의도적인 반올림이 있음을 알게 한다.
```java
double doubleVal = (double) longVal;
```
* 반올림 문제가 있는지 항상 다시 확인한다.
* 정밀도가 성능보다 중요할 경우 BigDecimal 타입을 사용한다. BigDecimal은 정밀도를 완전히 제어할 수 있다.