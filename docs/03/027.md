# 수치 오버플로
컴퓨터는 연산 속도를 높이기 위해 기본적으로 모든 숫자에 고정된 수의 비트를 할당한다.
다시 말해, 값에 할당된 메모리 영역과 연산 결과의 비트 크기가 들어맞지 않으면 수치 오버플로를 감수해야 한다는 뜻이다.

## 자바의 오버플로
기본적으로 자바는 수치 연산 오버플로가 발생하면 그저 조용히 틀린 결과를 낸다.
자바는 `int`, `long`, `float`, `double` 등의 네 가지 데이터 타입으로 수치 연산을 수행한다.
`byte`, `short`, `char` 등의 원시 숫자 타입은 다른 타입과 함께 연산에 포함되면 실제 연산 전에 `int`로 확장된다.
정수 타입의 오버 플로로 결과는 부동소수점 타입과 상당히 다르다.

`int`와 `long`의 계산 결과가 해당 타입의 비트 한계를 넘어서면 무조건 상위 비트가 삭제된다.
이 과정을 `2의 보수 규칙`과 관련있다.

* 두 `int` 값을 더하거나 뺀 결과가 `Integer.MAX_VALUE(2,147,483647)` 보다 크면 올바른 결과값에서 2^32를 뺀다. 따라서 항상 음수가 나온다.
* 두 `int` 값을 더하거나 뺀 결과가 `Integer.MIN_VALUE(-2,147,483648)` 보다 작으면 올바른 결과에 2^32를 더한다. 따라서 항상 양수가 나온다.
* 두 `int` 값을 곱한 결과가 오버플로되면 원래 숫자와 전혀 다른 무작위 숫자가 나온다. 엄밀히 말해서 무작위는 아니지만 이 값에서 실용적인 의미를 찾기란 거의 불가능하다.
* 두 `int` 값을 나눈 결과는 단 한 가지 경우, `Integer.MIN_VALUE / -1`를 제외하면 절대 오버플로 되지 않는다.

오버플로의 문제는 조용히 발생하는 것이다.
즉시 감지하지 못하면 훨씬 나중에 많은 추가 계산을 동원해야만 결과가 잘못되었다는 것을 알아차릴 수 있다.
즉 실수의 원인을 식별하기 어렵다.

> 실수 방지 가이드

* 정수 연산을 다룰 때에는 늘 오버플로 가능성을 고려한다. 곱셈은 연산 결과가 피연산자보다 상당히 커질 수 있으므로 가장 위험한 연산이다. int 피 연산자중 50,000이 넘는 수가 있으면 오버플로 가능성을 염두에 두고 더 주의 깊게 확인하는 것이 좋다.
* 정상적인 계산 결과는 데이터 타입에 부합하지만 중간에 오버플로가 발생할 위험이 있다면, 대수 변환 도는 비트 연산을 활용해 수식을 고친다.
```java
// x가 46,330 보다 클때 오버플로가 발생한다.
(x * x + 1_000_000) / x; 

// 오버플로가 발생하지 않는다.
x + (1_000_000 / x);
```
* 복잡한 계산은 가급적이면 라이브러리 메서드로 처리한다. 그중 일부 메서드는 계산 과정에서 발생할 수 있는 오버플로나 언더플로를 방지한다.
* 정수 계산에서 오버플로를 방지하려면 `BigInteger` 클래스를 사용하면 된다. 단순 연산보다는 상당히 느려질 가능성은 있지만 오버플로는 확실히 예방할 수 있다.
* 일반 연산자 대신 `Math.*Exact`를 사용하면 수치 오버플로 예외를 감지할 수 있다.

## int 곱셈의 long 변수 할당
정수 곱셈 결과를 `long` 변수에 할당하거나 `long` 파라미터로 전달할 때도 오버플로가 자주 발생한다.
가장 흔한 사례는 단위 변환이다.
```java
void process(int second) {
    long microseconds = second * 1_000_000;
    useMicroseconds(microseconds);
}
```
이 코드는 2,147초(약 35분)까지는 정상적으로 작동한다.
하지만 그보다 큰 값이 입력되면 곱셈에 오버플로가 발생하며 조용히 오작동할 것이다.
자바에서는 할당된 변수 타입에 수학적 표현타입을 결정하지 않으므로 결과를 `long` 변수에 할당하더라도 곱셈은 `int` 타입으로 수행된다.
이 코드의 문제는 다음과 같이 `L` 접미사를 붙이면 간단히 고칠 수 있다.
```java
long microseconds = seconds * 1_000_000L;
```

> 실수 방지 가이드

* 두 수를 곱하고 그 결과를 `long`에 할당할 때, 적어도 하나의 피연산자를 `long`으로 만들면 잠재적인 오버플로를 방지할 수 있다. 명시적으로 `(long)` 캐스트를 추가하거나 리터럴에 L 접미사를 붙이면 된다.
* 수동으로 계산하는 대신 전용 API 메서드를 사용한다. 이번 예시는 다음과 같이 `TimeUnit` 열거형을 사용할 수 있다.
```java
long microseconds = TimeUnit.SECONDS.toMicros(seconds);
```
* 가능하면 큰 숫자로 코드를 테스트 한다.

## 파일 크기, 시간, 재무 계산
일반적으로 품목 가격이나 계좌 잔액 등은 `BigDecimal`타입에 저장할 것을 권장한다.
그러나 `BigDecimal`은 상황에 따라 감당키 어려운 성능 오버헤드를 일으킬 위험이 있다.
`float`, `double`도 안전한 대안은 아니다. 반올림 에러가 결괏값에 악영향을 미칠 수 있기 때문이다.

> 실수 방지 가이드

* 매우 불가피한 사유가 없는 한 파일 크기와 파일 오프셋은 항상 `long` 타입에 담는다. 오프셋을 계산할 때는 먼저 피연산자를 `long`타입으로 변환한다.
* 2GB보다 큰 파일로 코드를 테스트 한다.
* 소프트웨어가 장래 처리할 수량을 과소평가하지 않는다. 오늘까지 터무니없이 커보이는 수치도 당장 내일부터 완전히 평범한 규모처럼 여겨질지 모른다.
* 날짜 값이나 시간 간격을 숫자로 변환할 때에는 언제 오버플로가 발생할지 미리 계산한다. 그 시점이 아주 머나먼 미래가 아니라면 더 큰 숫자타입을 사용하는 것이 좋다.

