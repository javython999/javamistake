# 특수한 부동소수점 수
부동소수점 숫자 중 몇몇은 특수하게 처리하거나 예기치 못한 연산 결과에 대비해야 한다.

## 부호가 있는 0: +0.0과 -0.0
부동소수점에는 두 가지 0이 있다. +0.0, -0.0이다.
컴퓨터 메모리에서 서로 다르게 표현되지만 `==`로 비교하면 같다고 판정된다.
-0.0은 일부 특수한 계산의 결과로 얻을 수 있다.
```java
System.out.println(-1 * 0.0);
```
다음 코드는 -0.0을 출력한다.
'두 피연산자의 부호가 같으면 결과의 부호는 양수, 다르면 음수다.'
이러한 동작은 자바에만 국한되지 않는다.
IEEE 754 표준을 따르는 모든 프로그래밍 언어는 같은 방식으로 작동한다.

double 값이 Double로 박싱 될 때, +0.0과 -0.0은 서로 다른 값이 된다는 점에 주의해야 한다.
```java
Double d = 0.0;
System.out.println(d.equals(-0.0)); // false
System.out.println(d == -0.0);  // true
```
Double.equals()은 각각 박싱된 0.0과 -0.0이 서로 다르다고 판단한다.
그러나 언박싱된 Double 값과 -0.0을 원시 비교하면 true가 반환된다.

> 실수 방지 가이드
* 자바는 내부적으로 +0.0과 -0.0을 구분하며 이 차이가 코드에 영향을 미칠 수 있다는 점을 명심한다. 이를 예방하려면 필드나 컬렉션에 값을 저장하기 전에 다음과 같이 정규화 한다.
```java
if (d == -0.0) d = 0.0;
```
* 부동소수점 숫자와 정확한 값 사이의 비교를 지양한다. 부동소수점 숫자를 세트에 저장하는 것도 좋은 생각이 아니다. 설령 음수가 없다 하더라도 제한된 기계 정밀도 때문에 기존 원소와 정확하게 비교할 수 없다.


## 숫자가 아님: NaN
`NaN`은 `숫자가 아님`을 의미한다. `Double.NaN`과 `Float.NaN`은 매우 특별한 값들이다.
이들은 심지어 자기 자신과도 같지 않은 유일한 값이다.
```java
System.out.println(Double.NaN == Double.NaN); // false
System.out.println(Float.NaN == Float.NaN); // false
```
숫자가 NaN인지 확인하려면 `Double.isNaN`이나 `Float.isNaN` 라이브러리 메서드를 사용하는 것이 좋다.

> 실수 방지 가이드
* 부동소수점 숫자를 비교할 때 NaN이 끼어들 가능성이 있는지 검토한다.
* NaN을 허용하지 않아야 할 곳은 다음과 같이 assert를 추가 한다.
```java
assert !Double.isNaN(a);
```
* 공용 API는 다음과 같은 사전 조건을 추가 한다.
```java
if (Double.isNaN(a)) {
    throw new IllegalArgumentException();
}
```

## Double.MIN_VALUE는 최소값이 아니다.
`Double.MAX_VALUE`는 실제로 double 타입에서 가장 크고 유한한 값이지만 `Double.MIN_VALUE`는 최솟값이 아니다.
정확히 말해 이 상수는 double 타입으로 표현할 수 있는 가장 작은 양수 값이며 대략 4.9 x 10^-324이다.
double 타입의 최솟값을 나타내는 명시적인 상수는 없지만, 꼭 필요한 경우 `-Double.MAX_VALUE`를 쓰면된다.

> 실수 방지 가이드
* double 타입의 유한한 최솟값이 필요할 때에는 Double.MIN_VALUE 대신 -Double.MAX_VALUE를 사용한다. 또한 무한대 값을 처리할 피룡가 있는지 검토한다.
* 정수 타입을 부동소수점 타입으로 마이그레이션할 때는 신중을 기해야 한다. int를 double로 Integer를 Double로 무작정 교체하면 컴파일은 가능할지 몰라도 의미론적인 실수가 발생할 위험이 있다. 마이그레이션 후 코드를 꼼꼼히 검토하고 테스트 해야 한다.
* 배열의 최댓값 검색 등의 표준적인 알고리즘은 가능한 라이브러리를 통해 계산한다. 대부분의 경우 `max()` 함수를 직접 만들기보다 `DoubleStream.of(values).max()`를 쓰는 것이 낫다. 구글 구아바 라이브러리를 사용한다면 `Doubles.max()`라는 유틸리티 메서드를 쓰면 된다.