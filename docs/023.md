# 잘못된 초기화 순서

## 정적 필드
```java
class MyHandler {
    public static final MyHandler INSTANCE = new MyHandler();
    private static final Logger LOG = Logger.getLogger(MyHandler.class.getName());
    
    private MyHandler() {
        try {
            ...
        } catch (Exception e) {
            LOG.log(Level.SEVERE, "Initialization error", ex);
        }
    }
}
```
`MyHandler`의 싱글턴 인스턴스는 클래스 초기화 과정에 생성된다.
`MyHandler` 생성 도중 예외가 발생하면 로그가 제대로 남지 않을 것이다.
아직 초기화 되지 않은 `LOG` 필드를 역참조 하기 때문이다.
결과적으로 클래스 초기화 실패시 `NullPointerException`이 발생하며 근본적인 문제를 가려버린다.

> 실수 방지 가이드

* 클래스나 객체를 신중하게 초기화한다. 복잡한 호출 과정은 초기화에서 제거하거나, 꼭 필요한 경우 초기화 마지막 단계로 옮긴다. 그것도 어렵다면 호출당하는 메서드 쪽에서 이 클래스가 완전히 초기화되지 않았음을 대비하고 있는지 확인해야 한다.
* 실행 사례가 드문 코드 경로라 해도 테스트에 배제하지 않는다. 특히 로그를 남기는 코드는 평상시에 거의 실행되지 않지만 향후 문제 발생 시 원인 규명에 매우 중요한 역할을 한다. 이 코드가 제대로 작동하지 않으면 사용자 로그나 서버 로그에 무의미한 정보가 담길 위험이 있다.


## 서브클래스 필드
```java
class Entity {
    final int id;
    
    Entity() {
        id = generateId();
    }
    
    protected int generateId() {
        return 0;
    }
}
```

```java
import java.util.Random;

class RandomIntEntity extends Entity {
    final Random random = new Random();
    
    @Override
    protected int generateId() {
        return random.nextInt();
    }
}
```
`RandomIntEntity` 인스턴스를 생성하려면 무조건 NullPointerException이 발생한다.
`random` 필드는 실제로 `RandomIntEntity` 클래스 생성자의 일부이며 슈퍼클래스 생성자 실행 이후 초기화된다.
슈퍼클래스 생성자가 실행될 때 하위 클래스 필드는 아직 초기화되지 않은 상태다.
그러나 예시에서 오버라이딩한 `generateId()` 메서드는 `random` 필드가 이미 초기화되었다고 간주한다.

> 실수 방지 가이드

* final이 아닌 클래스 생성자에서 final이 아닌 인스턴스 메서드를 호출하지 않는다. 기본적으로 생성자는 가능한 한 단순하게 유지한다. 헬퍼 메서드는 처음부터 static, private, final로 선언해서 서브 클래스가 오버라이딩할 수 없도록 한다.
* 중요한 초기화 로직은 생성자에서 뺀다. 이를테면 id 필드 초기화는 처음 접근한 순간까지 지연시켜도 된다.
```java
class Entity {
    Integer id;
    
    int getId() {
        if (id == null) {
            id = generateId();
        }
        return id;
    }
    
    protected int generateId() {
        ...
    }
}
```

## 클래스 초기화 순서
두 클래스의 초기화가 서로 의존 관계에 있으면 문제가 생기기 쉽다.
클래스 A의 초기화가 클래스 B에 의존하고, 클래스 B의 초기화가 클래스 A에 의존하면 문제가 생기기 시작한다.

```java
class A {
    private static final B unused = new B();
    static final String WELCOME = "Hello".toUpperCase();

    public static void main(String[] args) {
        System.out.println(B.MSG);
    }
}

class B {
    static final String MSG = A.WELCOME;

    public static void main(String[] args) {
        System.out.println(B.MSG);
    }
}
```

> 실수 방지 가이드

* 클래스 초기화는 가능한 한 단순하게 만든다. 복잡한 요소는 가급적 초기화로부터 지연시킨다. 정적 필드를 public으로 노출하는 것보다 온디맨드 초기화 메서드를 만드는 것이 낫다.
* 프로그램에 순환 초기화 문제가 있다면 나중 일로 미루지 말고 최대한 빨리 수정한다. 추후 실제로 데드락이 발생했을 때는 이를 바로잡기 어렵다.
* 프로그램이 여러 클라이언트를 병렬로 서비스한다면 반드시 자동 테스트로 검증해야 한다. 순차적으로 잘 작동하는 프로그램도 여러 요청을 병렬로 처리하면서 심각한 문제를 드러내기도 한다.
* 자바를 최신 버전으로 업그레이드 한다. jstack 등의 최신 모니터링 도구는 이 문제를 처리할 수 있을 정도로 발전했다.

## ENUM 초기화 루프
자바의 enum 타입은 사전 정의 상수로 구성된다.
대체로 상수가 초기화된다는 사실을 관과한다.

```java
enum Pet {
    DOG(Voice.BARK),
    CAT(Voice.MEOW);
    
    final Voice voice;
    Pet(Voice voice) {
        this.voice = voice;
    }
}

enum Voice {
    BARK(Pet.DOG),
    MEOW(Pet.CAT);
    
    final Pet pet;
    Voice(Pet pet) {
        this.pet = pet;
    }
}
```
> 실수 방지 가이드

* 가상 머신 관점에서 열거형은 기본적으로 일반 클래스이며 열거형 상수는 정적 필드로 초기화된다는 점을 잊지 말아야 한다. 생성자에서 특정 작업을 처리할 때는 해당 열거형 클래스가 완전히 초기화되지 않은 상태임을 감안한다.
* 자바 21 이상의 환경이 아니라면 열겨형을 초기화하는 동안 switch에서 해당 열거형을 사용하지 않도록 한다.