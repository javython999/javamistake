# char 값을 문자로 간주
개발자들은 종종 자바의 `char` 타입이 하나의 표현 문자를 나타낸다고 간주한다.
이러한 단정은 일반적으로 틀리지 않았지만 유니코드가 개입하면 이야기가 달라진다.

> 실수 방지 가이드
* 임의의 문자가 포함된 문자열은 char용 API 대신 코드포인트용 API를 사용한다.
String  클래스에는 codePointAt(), codePointBefore(), codePointCount(), codePoints() 등의 메서드가 있다.
문자열을 생성할 때에는 StringBuilder 클래스의 appendCodePoint() 메서드가 유용하다.
이들을 조합하면 다음과 같이 스트림 API로 문자열 일부를 추출할 수 있다.
```java
String part = string.codePoints().skip(rowNumber * rowLength)
        .limit(rowLength)
        .collect(StringBuilder::new, StringBuilder::appendCoidPoint, StringBuilder::append)
        .toString();
```
이 코드는 substring()을 사용했던 코드보다 복잡하고 사용하기도 어렵다. 게다가 charAt()과 substring() 등의 char 메서드 상수 시간 복잡도로 작동한다.
반면 코드포인트용 메서드는 n번째 코드포인트를 찾기 위해 문자열에서 서로 쌍을 이루는 모든 조합을 처음부터 확인해야 한다.
따라서 코드포인트 방식으로 프로그램을 리팩터링하면 전보다 더 느려질 가능성이 있다.
그렇다면 이 코드는 문자열을 한 번만 탐색할 수 있는 구조로 재조정하는 것도 좋다.
한 번 순회하는 과정에서 분할 문자열을 모두 추출해두면 된다.
codePointAt() 메서드는 잘 이해하고 사용해야 한다.
이 메서드는 n번째 코드포인트를 찾는 메서드처럼 보이지만 실제로는 n번째 char 자리에 있는 코드포인트를 반환한다.
n번째 코드포인트를 바로 찾을 수 있는 메서드는 자바 표준라이브러리에 없다.
* char 타입을 입력 받는 isDigit(char) 등의 라이브러리 메서드는 가급적 사용하지 않는다. 이들은 BMP 바깥의 문자를 지원하지 않으므로 int 타입으로 코드포인트를 입력 받는 오버로드 메서드를 사용하는 것이 좋다.
* char 타입은 최대한 멀리한다. 특히 공용 API의 메서드 파라미터나 반환값에 char를 사용하면 위험하다.
이러한 메서드 중 상당수는 서로게이트 페어를 만나면 폭발하는 시한폭탄이나 마찬가지다. 또한 char를 기준으로 API르 설계하면 추후 리팩터링 하기 어렵다.
조금 힘들더라도 처음부터 코드포인트를 기준으로 설계하는 것이 더 좋다.
* 사용자에게 보여줄 텍스트는 더욱 전문적인 텍스트 API로 처리한다. 예를 들어 문자열을 나눌 때는 BreakIterator 클래스에 속한 getCharacterInstance() 메서드를 쓰면 좋다.
이 메서드는 서로게이트 페어뿐만 아니라 조합 문자 시퀀스와 합자 클러스터도 인식한다.
* 텍스트 처리 코드는 각각을 모두 격리시키는 것이 좋다. ICU4J 등의 전용 라이브러리를 쓰거나 자체적으로 유틸리티 메서드를 작성하라. 텍스트는 처리하기 까다롭다. 재사용 코드가 늘어날수록 테스트하고 수정할 코드는 줄어든다.