# 048. 포맷 인수 불일치
`String.format()`, `PrintStream.printf()` 등의 메서드는 포맷 문자열과 추가 인수를 입력 받는다.
추가 인수는 포맷 문자열에 포함된 지정자가 참조하는데, 여기서 이 둘의 관계를 일치시키지 않는 실수가 자주 생긴다.

개발자가 포맷 문자열을 바꾸면 인수도 그에 맞게 조정해야 한다.
그러나 인수 추가, 제거, 순서 변경 등의 작업을 잊고 넘어가는 경우가 많다.
물론 자바 컴파일러는 이러한 문제를 경고하지 않으며, 결과적으로 문자열이 제대로 포맷되지 않거나 런타임 예외가 발생한다.

```java
System.out.printf("Length is %d", "123"); // IllegalFormatConversionException
System.out.printf("Hello, %s"); // MissingFormatArgumentException
```
포맷 인수가 일치하지 않는다 하여 반드시 런타임 예외가 발생하는 것은 아니다.
특히 미사용 인수는 그저 간단히 무시해버린다.

> 실수 방지 가이드 
* 문자열 생성과 실제 출력 로직을 분리하면 출력 문자열을 유닛 테스트로 쉽게 검증할 수 있다.
가령 다음과 같이 환영 인사를 출력하는 명령줄 애플리케이션 메서드가 있다고 가정해보자.
```java
void greetUser(String userName) {
    System.out.printf("Hello, %s!%n", userName);
}
```
* 여기서 문자열 생성 코드는 다음과 같이 `String.format()` 메서드로 추출하는 것이 더 낫다.
```java
void greetUser(String userName) {
    System.out.print(getGreeting(userName));
}

String getGreeting(String userName) {
    return String.format("Hello, %s!%n", userName);
}
``` 
이제 `getGreeting()` 메서드는 매우 쉽게 유닛 테스트를 만들 수 있다.
문자열 포매팅 과정에 실수가 있으면 유닛 테스트도 실패할 것이다.

* 포맷 지정자가 참조할 인수를 명시적으로 지정할 수 있다.
```java
System.out.printf("Hello, %2$s! Today is %1%tD.", LocalDate.now(), "John");
```
`%2$s`는 두 번째 추가 인수를 사용하라는 뜻이다.
가급적이면 이 방식으로 인수를 참조하기 바란다.
간단한 구문이지만 코드는 이전보다 훨씬 견고해졌다.
