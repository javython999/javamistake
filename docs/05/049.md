# 정규 표현식 대신 일반 문자열 사용
String 클래스에서 matches(), replaceFirst(), replaceAll(), split() 등의 일부 메서드는 정규 표현식 문자열을 인수로 받는다.
그러나 가끔 이들이 리터럴 문자열을 인수로 받는다고 착각하는 경우가 있다.

```java
String javaPackage = "java.util.concurrent";
String[] parts = javaPackage.split(".");
```
이 코드의 원래 의도는 "java.util.concurrent" 문자열을 ["java", "util", "concurrent"] 배열을 얻는 것이었다.
하지만 구분자로 전달한 마침표는 정규표현식에서 `모든 문자`를 의미하므로 입력 문자열의 모든 문자가 구분자로 인식될 것이다.
`javaPackage` 문자열은 20자이며 결국 split()의 결과는 빈 문자열이 21개 담긴 배열이 되어야 한다.
그러나 split() 메서드의 독특한 작동 방식 덕에 실제로 이런 일은 벌어지지 않는다.
기본적으로 split() 메서드는 결과 배열의 마지막에 있는 빈 문자열은 제거한다.
split(".")을 호출하면 결과의 모든 빈 문자열이 제거되므로 입력값이 무엇이든 빈 배열을 반환한다.
마침표 문자열 자체를 구분자로 쓰려면 백슬래시로 이스케이프해야 한다.

또는 다음과 같이 Pattern.quote() 정적 메서드를 사용하는 방법도 있다.
```java
String[] parts = javaPackage.split(Pattern.quote("."));
```

> 실수 방지 가이드
* String.split()은 정규 표현식으로 문자열을 나눌 때 이외에는 쓰지 않는다. 또한 자바 표준 라이브러리만으로 구현한다면 다음과 같이 사용해야 안전하다.
```java
String[] parts = Pattern.comile(delimiter, Pattern.LITERAL)
        .split(stringToSplit);
```
이 코드는 delimiter로 전달한 문자열이 단순한 리터럴임을 명시적으로 알린다. 또한 유틸리티 메서드로 추출하기도 쉽다.
서드파티 라이브러리가 허용된다면 문자열을 분할하는 대체재는 많다.
다음은 구아바 라이브러리의 Splitter API로 문자열을 나누는 방법이다.

```java
List<String> parts = Splitter.on(delimeter)
        .splitToList(stringToSplit);
```
아파치 커먼즈 랭 또한 널리 쓰인다.
이 라이브러리에 있는 StringUtils 클래스는 다양한 방식으로 문자열을 분할할 수 있다.

```java
String[] parts = StringUtils.splitByWholeSeparator(stringToSplit, delimiter);
```

* split() 등의 문자열 조작 메서드로 파일 경로를 처리하지 않는다.
OS에 독립적인 방식으로 파일 경로를 안전하게 처리하는 모든 메서드는 Path 클래스 안에 있다.
특히 Path 변수를 직접 순회하면 다음과 같이 경로 컴포넌트를 차례로 얻을 수 있다.
```java
Path absolutePath = Path.of(".").toAbsolutePath();
for (Path path : absolutePath) {
    System.out.println(path);
}
```