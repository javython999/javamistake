# 문자열의 대소문자 비교
대소문와 무관하게 문자열을 비교할 때에는 보통 `toLowerCase()` 또는 `toUpperCase()` 메서드로 문자열을 정규화한다.
그러나 처음에는 없다가 나중에 추가된 대소문자 변환 코드는 버그로 이어질 수 있다.

```java
if (filterMessage.startWith("Each")) {
    ...
}

// 문자열 정규화 코드 추가
if (filterMessage.toLowerCase(Locale.ENGLISH).startWith("Each")) {
    ...
}
```
정규화 뒷부분의 상수에 대소문자 변환이 적용되지 않았다.
소문자만 있는 문자열은 `E`로 시작할 수 없으므로 이 조건은 절대 참이 되지 않는다.

> 실수 방지 가이드
* 조건 비교 이전에 대소문자를 정규화해야 한다면 신중하게 처리한다. 이러한 작업은 에러의 원인이 될 가능성이 있다. 조건이 실제로 작동하는지 확인하는 유닛 테스트를 추가하다.
* 검색하려는 문자열이 상수가 아닐 경우, 어셜션이나 사전 조건을 추가하는 식으로 예방조치를 취한다.
```java
boolean hasOneOfPrefixes(String str, Set<String> prefixes) {
    String lowercased = str.toLowerCase(Locale.ROOT);
    for (String prefix : prefixes) {
        assert prefix.equals(prefix.toLowerCase(Locale.ROOT));
        if (lowercased.startsWith(prefix)) {
            return true;
        }
    }
    return false;
}
```
이 코드가 작동하려면 접두사가 이미 소문자여야 한다.
이러한 전제가 없는 한 접두사는 아무 역할도 하지 못할 것이다. 
assert 문은 이러한 상황을 감지하는 신호 역할을 할 수 있다.
* String 클래스에는 regionMatches() 메서드가 있다. 이 메서드는 대소문자 구분 없이 문자열에 접두사 또는 접미사를 비교할 때 사용할 수 있다.
```java
String prefix = "Each ";
int len = prefix.length();
if (filterMessage.length() >= len && filterMessage.regionMatches(true, 0, prefix, 0, len)) {
    ...
}
```
다음과 같이 유틸리티 메서드를 만들어 활용하면 좋다.
```java
public static boolean startWithIgnoreCase(String str, String prefix) {
    int strLen = str.length();
    int prefixLen = prefix.length();
    return strLen >= prefixLen && str.regionMatches(true, 0, prefix, 0, prefixLen);
}
```
