# IndexOutOfBoundsException
리스트 크기를 벗어난 원소에 접근하려고 할 경우 `IndexOutOfBoundsException`등의 적절한 예외가 발생한다.
예외의 존재 여부와 무관하계 경계 검사는 매번 직접하는 것이 마땅하다.
`IndexOutOfBoundsException`은 자바 프로그램에서 다양한 형태로 매우 흔하게 발생하기 때문이다.

```java
void processString(String s) {
    if (Character.isDigit(s.charAt(0))) {
        processStringStartingWithDigit(s);
    }
}
```
이 코드는 빈 문자열(`""`)이 입력되지 않을 때만 잘 작동한다.
배열과 리스트에서도 이와 비슷한 버그가 자주 발생한다.

 경계 검사를 넣긴 했지만 잘못 구현하는 경우도 있다.
 이러한 문제는 크게 세 가지 형태로 분류할 수 있다.
 
* 인덱스 접근 이후 경계 검사
  * 주로 리팩터링 또는 복사-붙여넣기 실수가 원인이다.
```java
void processArrayElement(int[] data, int index) {
    if (data[index] >= 0 && index < data.length) { // 검사 효과 없음. index가 경계를 벗어나면 이미 예외가 발생한다.
        ...
    }
}
```
* 검사 조건 반전: 당므 코드는 원래 data.length > index를 확인하려 했다.
```java
void processInput(int[] data, int index) {
    if (data.length < index && data[index] >= 0) { // 인덱스가 경계를 ㅁ벗어난 경우에만 진행한다.
        
    }
}
```
* 오프 바이 원 에러: 배열, 리스트, 문자열의 길이와 정확히 같은 인덱스가 있을 때 발생하는 코너 케이스다.
  * 이러한 인덱스는 분명히 범위 밖에 있지만 개발자들은 종종 이를 간과한다.
```java
void processInput(int[] data, int index) {
    if (index > data.length) return;    // 인덱스가 data.length와 같으면 다음 줄이 계속 실행되며 예외가 발생한다.
    
    if (data[index] >= 0) {
        ...
    }
}
```
> 실수 방지 가이드
* 클라이언트로부터 인덱스 값을 받으면 즉시 경계 범위를 검사한다. 실수는 빨리 발견할 수록 좋다.
* 인덱스 수치를 비교할 때는 신중을 기하고 `<`, `<=`, `>`, `>=` 연산을 혼동하지 않도록 주의한다.
* 코드 문서화를 장려하고 정적 분석 도구의 활용성을 높이기 위해 범위 애노테이션을 적극 활용한다.