# StackOverflowError
재귀는 루프보다 더 깔끔한 방식으로 다양한 알고리즘을 구현할 수 있게 해준느 유용한 프로그래밍 기법이다.
재귀 호출은 스레드의 스택을 소모하며 호출 단계가 지나치게 깊어지면 `StackOverflowError`가 발생한다.

## 깊지만 유한한 재귀
일부 프로그래밍 언어, 특히 함수형 프로그래밍 언어는 컴파일 과정에서 꼬리 재귀를 자동으로 제거한다.
꼬리 재귀란 메서드 끝에서 실행되는 재귀 로직을 일컫는다.
모든 꼬리 재귀 코드 로직은 소스 코드 상에서 기계적인 절차에 따라 루프로 전환할 수 있다.
루프로 변환된 코드가 썩 예쁘지는 않겠으나, 적어도 스택 오버플로 걱정은 없다.

* 꼬리 재귀
```java
static int indexOf(String s, int start, char c) {
    if (start >= s.length()) return -1;
    if (s.charAt(start) == c) return start;
    return indexOf(s, start + 1, c);
}
```
* 루프 변환
```java
static int indexOf(String s, int start, char c) {
    while (true) {
        if (start >= s.length()) return -1;
        if (s.charAt(start) == c) return start;
        start = start + 1;
    }
}
```
재귀 호출의 깊이가 몇 백 단계 미만이라는 확신이 없는 한, 자동이든 수동이든 이처럼 꼬리 재귀를 반복문으로 변환할 것을 권장한다.
안타깝게도 모든 재귀 로직이 꼬리 호출 형태는 아니므로 이러한 최적화도 항상 가능하지 않다.
그러나 재귀 로직을 반복문으로 고치는 것은 어떤 식으로든 가능하다.
다만 호출 상태를 지속적으로 저장해두려면 프로그램 힙에 별도의 컬렉션을 둬야 한다.
보통 이런 식으로 호출 스택을 에뮬레이트할 때 `ArrayDeque` 컬렉션이 적합하다.

```java
record Node(String name, Node ...children) {
    Node find(String name) {
        if (name().equals(name)) return this;
        for (Node child: children()) {
            Node node = child.find(name);
            if (node != null) return node;
        }
        return null;
    }
}
```
이 메서드는 간단하고 명확하며 대부분의 경우 문제없이 사용할 수 있다.

```java
Node root = new Node("root", new Node("child1", new Node("grandchild")), new Node("child2"));
System.out.println(root.find("grandchild"));
```
이 트리의 계층 구조가 매우 깊어질 것이 확실하다면 재귀 코드를 제거하는 것이 좋다.
그러기 위해서는 방문할 노드 목록을 다음과 같은 방식으로 컬렉션에 담아두어야 한다.

```java
import java.util.ArrayDeque;
import java.util.Deque;

Node find(String name) {
    Deque<Node> stack = new ArrayDeque<>();
    stack.add(this);
    while (!stack.isEmpty()) {
        Node node = stack.pollLast();
        if (node.name().equals(name)) return node;
        Collections.addAll(stack, node.children());
    }
    return null;
}
```
내용은 조금 더 길어졌고 이해하기도 어려웠지만 이 메서드의 한계는 스택 크기가 아닌 힙 크기로 제한된다.
따라서 이전보다 훨씬 더 깊은 트리를 탐색할 수 있다.

> 실수 방지 가이드
* 재귀 호출이 스택 용량을 초과할 가능성이 있는지 항상 확인한다.
일반적으로 가상 머신은 1,000 ~ 10,000번 정도의 재귀 호출을 처리할 수 있다.
그러나 이 횟수는 메서드의 파라미터와 로컬 변수의 개수, 인터프리터 또는 JIT 컴파일 방식에 따라 다르다.
만일 깊이가 천 단위에 이를 것이라 예상되면 스택 공간 대신 힙을 사용하는 것이 안전하다.
* 표준 알고리즘을 손수 구현하지 않도록 한다. 그래프나 트리 탐색 등의 보편적이 알고리즘을 구현하기 위해 재귀를 쓰는 경우가 많다. 그러나 이미 잘 검증된 라이브러리 메서드를 쓰면 재귀를 사용할 필요가 없다.