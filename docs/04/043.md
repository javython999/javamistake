# ClassCastException
자바에서 `ClassCastException`이 발생하는 원인은 주로 두 가지다.
1. 명시적 타입 캐스트 표현
2. 제네릭 타입이 인스턴스화될 때 추가되는 묵시적 캐스트

## 명시적 캐스트
명시적 캐스트에서 `ClassCastException`을 방지하려면 다음 코드처럼 해당 캐스트를 매번 `instanceof` 검사로 보호하는 것이 좋다.
```java
if (obj instanceof MyType) {
    MyType myType = (MyType) obj;
}
```
자바 16부터는 `instnaceof` 표현법이 개선되었다.
```java
if (obj instanceof MyType myType) {
    ...
}
```
`MyType myType` 부분은 패턴이라고 부른다.
패턴 기반 `instanceof` 표현은 명싲거 캐스트와 달리 결코 `ClassException`을 일으키지 않으므로 그에 대한 보호 조치도 필요 없다.

> 실수 방지 가이드
* 자바 16부터 `instanceof` 구문과 패턴 매칭을 연계하도록 강력히 권고하고 있다. 이러한 방식으로 `instanceof`와 캐스트 작업을 하나로 묶으면 대상 타입을 한 번만 언급하게 되므로 복사-붙여넣기 실수를 예방할 수 있다.
* `equals()`를 구현할 때 다른 클래스의 코드를 베끼지 않는다. 그 대신 IDE를 이용해 처음부터 메서드를 새로 생성한다. 복사-붙여넣기는 캐스트 타입 수정 누락 등의 실수를 유발한다.
* `instanceof` 검사로 예방 조치를 취하기 전에는 타입을 캐스팅하지 않는다. 변수에 담길 타입이 정해져 있다고 확신한다면 변수를 해당 타입으로 바꾸는 것이 맞다. 기존 메서드 파라미터 또는 반환 타입과 충돌하더라도 그 쪽을 고치고 캐스트를 제거하는 편이 낫다.
* `instanceof` 캐스트 코드는 템플릿 기능을 자동으로 생성하는 것이 좋다.

## 제네릭 유형과 묵시적 캐스트
`ClassCastExcetion`이 발생하는 또 다른 일반적인 원인은 제네릭 타입 인스턴스화 과정에서 발생하는 묵시적 캐스트다.

```java
void printFirstItem(List<String> list) {
    String s = list.get(0);
    System.out.println(s);
}
```
List 클래스느느 List<E>로 선언되었으면 get() 메서드는 E 타입을 반환한다.
그러나 자바는 런타임 시 제네릭을 지워버린다.
제네릭 타입은 소스 코드 안에서만 볼 수 있는 존재였다. 자바 프로그램이 실행되면 제네릭 타입 인수는 더 이상 확인할 수 없으며 모든 타입 파라미터(E)는 상한 타입(명시적 상한이 없으면 Object)으로 대체된다.
따라서 Object 타입을 String으로 변환하기 위해 자바 컴파일러는 묵시적 캐스트를 삽입하며, 메서드는 다음과 같이 디슈거 된다.

```java
void printFistItem(List list) {
    String s = (String) list.get(0);
    System.out.println(s);
}
```

> 실수 방지 가이드 
* 자바 타입 시스템의 한계를 극복하기 위해 간혹 미확인 캐스트를 쓰는 경우가 있다. 하지만 미확인 캐스트가 꼭 필요한지, 다른 방법으로 해결할 수 없는지, 결과는 어떻게 되는지 반드시 이해한 뒤에 사용해야 한다.
미확인 캐스트가 사용된 코드는 잘 테스트된 유틸리티 메서드로 캡슐화하고, 그러지 못할 때는 해당 용도에 맞는 기성 메서드를 활용하는 것이 좋다.
미확인 캐스트만 분리해 소형 메서드로 추출한 다음 `@SuppressWarning("unchecked")`를 지정하면 경고를 억제할 수 있다.
* Collections.unmodifiableList() 등의 어댑터 메서드로 미확인 캐스트를 방지하는 경우가 있다.
* 메서드를 선언할 때 와일드카드를 활용해 더 일반적인 제네릭 타입 파라미터를 지정할 수 있다. 읽기 전용 객체로 사용할 때는 `? extends`, 쓰기 전용 객체로 사용할 때에는 `? super`를 지정해야 한다.
이 기법은 흔히 `Producer Extends, Consumer Super`의 약자를 딴 `PECS`로 통칭한다.
PECS는 미확인 캐스트를 줄이는 원리인 동시에 코드를 통해 더욱 명확한 정보를 전달하는 수단이다.
메서드 선언부만 봐도 읽기 전용인지 또는 쓰기 전용인지 알 수 있기 때문이다.
* 제네릭 타입 객체를 배열에 저장하지 않는다. 자바는 제네릭 배열을 만들 수 없으므로 제네릭 타입 객체 배열을 미확인 캐스트를 통해 처리할 수 밖에 없다.
이러한 배열은 대부분의 경우 ArrayList로 대체할 수 있다. ArrayList는 이미 배열을 캡슐화하고 있으며 미확인 캐스트는 구현 내부에 은닉한다.
* raw 타입은 가급적 사용하지 않는다. raw 타입은 컴파일러의 검사 기능을 약화시키므로 잘못된 타입의 객체가 어딘가에 저장될 위험성을 높인다.
현대 자바 프로그램에서 raw 타입이 쓰이는 경우는 매우 드물다. 그중 하나의 용도가 제네릭 타입 배열 생성이지만, 좋은 생각이 아니다.
* javac 컴파일러에 -Xlint:rawtypes 옵션을 지정하면 프로그램에 쓰인 raw 타입을 검색할 수 있다.
이 정보를 바탕으로 모든 raw 타입을 근절하라.
* Collections 유틸리티 클래스에 checkList(), checkedMap() 등의 래퍼 메서드가 있다.
이들은 컬렉션이나 맵에 추가되는 원소 타입을 제어한다. 
타입 안전성이 매우 중요한 작업을 할 때에는 이러한 래퍼를 먼저 고려하는 것이 좋다.
미확인 캐스트가 있다고 해도 객체 타입이 잚소 들어갈 염려는 없기 때문이다.
* printFirstItem() 예시 ArrayList는 다음과 같이 checkedList()로 래핑할 수 있다. 
이렇게 감싼 문자열 리스트에 숫자를 추가하려면 예외가 발생한다.
```java
List<string> list = Collections.checkedList(new ArrayList<>(), String.class);
List<?> objects = list;
((List<object>) objects).add(1); // 런타임시 ClassCastException 발생
printFirstItem(lsit);
```
* 모든 곳에서 이런 식으로 래퍼를 사용하라는 요구는 지나친 감이 있다.
그러나 적어도, 컬렉션 내부에서 잘 못된 타입이 등장하는 위치를 파악하려 할 때에는 이 방법이 효과가 있다.
컬렉션을 임시로 래핑하고 프로그램을 다시 실행하면, 해당 타입의 사용 지점이 아닌 추가 지점에서 예외가 발생할 것이다.

## 복수의 클래스 로더
자바 가상 머신은 클래스명과 클래스 로더를 기준으로 클래스를 구별한다.
일반적으로 `ClassCastException`이 발생하면 클래스명이 다르다는 의미로 받아들이면 된다.
그러나 클래스명은 동일하지만 클래스 로더가 다른 경우도 있다.
서로 다른 클래스 로더가 서로 다른 플러그인이나 모듈 클래스를 불러오는 경우가 있기 때문이다.

> 실수 방지 가이드
* `URLClassLoader` 등으로 동적 클래스로더를 정의할 때에는 부모 클래스 로더에 주의해야 한다.
특정 클래스가 제대로 작동하려면 슈퍼클래스와 인터페이스를 비롯한 다른 모든 클래스가 동일한 클래스 로더에서 로드되어야 한다.
그러나, 클래스 로더는 부모 클래스 로더를 통해 먼저 로딩을 시도하므로 부모가 발견한 클래스는 부모가 반환한다.
* 플러그인 아키텍처를 보유한 애플리케이션은 플러그인과 모듈의 경계를 살피고 이들 사이에서 객체가 전달되는 과정을 잘 관리해야 한다.
두 플러그인에서 동일한 라이브러리에 의존하지만 이를 각기 다른 클래스 로더에서 불러올 때도 있다. 
* 서로 다른 클래스 로더가 불러온 객체를 처리할 수 있는 마땅한 방법이 없다면 리플렉션을 사용하면 된다.
해당 객체를 Object 타입으로 저장하고 다음과 같이 리플렉션의 `getMethod()` 및 `invoke` API로 특정 메서드를 호출할 수 있다.
```java
obj.getClass().getMethod("myMethod").invoke(obj);
```
* 그러나 이러한 코드는 매우 위태롭다.이런 식으로 호출된 메서드가 실제로 존재하는지, 파라미터는 호환되는지, 컴파일러 시점에 검증할 수 없다.
이 방법을 쓸 때는 리플렉션 호출 코드를 별도의 메서드로 캡슐화하고 이렇게 된 사유를 주석으로 설명해야 한다.
또한 이 방법이 실제로 작동하는지 확인하는 유닛 테스트를 만들어야 한다.