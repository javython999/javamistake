# 맵에서 null 값 사용
컬렉션과 맵은 저마다 `null`을 대하는 성향이 다르다.
그러나 `null`을 온전히 지원하는 `HashMap` 등의 구현체를 쓴다 해도 `null` 값은 주의해서 다루어야 한다.
맵 인터페이스 메서드 중 일부는 `null` 값을 매핑과 매핑값의 부재 자체를 동일하게 표현한다.
반대로 `null` 값의 존재를 올바르게 처리하는 메서드가 있고, 두 방식을 섞어 놓은 듯한 메서드도 있다.

* `null` 값을 지원
  * `containsKey()`
  * `getOrDefault()`
  * `put()`

```java
map.put("x", null);
assert map.containsKey("x");
assert map.getOrDefault("x", "default") == null;
```

`put()` 메서드는 `null` 값을 올바르게 저장하며 `containsKey()`는 `true`를 반환하고 `getOrDefault()`는 `null` 값을 발견하고 기본값 대신 이를 그대로 반환한다.
그러나 `put()`의 반환값으로는 이전에 `null` 매핑이 있었는지 또는 매핑이 전혀 없었는지 분간할 수 없다.

* `computeIfPresent()`, `compute()`와 등의 메서드는 `null` 매핑과 값 부재를 구분하지 않는다.
`computeIfPresent()`는 리매핑 함수가 `null`을 반환하면 기존 매핑을 제거하고, 기존에 `null` 매핑이 있었다면 리매핑 함수를 아예 호출하지 않는다.
`get()` 메서드도 이런 식으로 작동한다. `null`을 반환했을 때 그것이 `null` 매핑인지 값의 부재를 나타내는지 알 수 없다.
* `merge()` 메서드는 맵에 새 값을 넣거나, 리매핑 함수를 통해 기존 값과 새 값을 가공해서 넣을 수 있다.
```java
V merge(K key, V value, BiFunction<? super V, ? super V, ? extends  V> remappingFunction);
```
이 메서드는 `compte()`와 마찬가지로 `null` 매핑과 값의 부재를 구분하지 않으며 리매핑 함수가 `null`을 반환하면 기존 매핑을 제거한다.
그러나 이 메서드는 `value` 인수가 `null`을 허용하지 않으므로 별도의 범주로 분류할 수 있다.

```java
var map = new HashMap<String, String>();
map.put("x", null);
map.merge("x", "1", (x, y) -> null); // null 매핑은 1로 대체, 병합 함수 미호출
System.out.println(map); // {x=1}
map.merge("x", "1", (x, y) -> null); // 병합 함수 호출, 기존 매핑 제거
System.out.println(map); // {}
map.merge("x", null, (x, y) -> null); // NullPointerException 발생
```
첫 번째 `merge()` 호출에서 `null` 매핑은 "1"로 대체되고 병합 함수는 호출되지 않는다.
두 번째 `mrege()` 호출에서는 병합 함수를 실행하고 `null`을 반환 받으므로 기존 매핑이 삭제된다.
세 번째 호출에서는 `null`을 인수로 전달한다. 이 경우 `merge()` 메서드는 새로운 `null` 매핑을 추가하거나 `null`을 단순히 '부재'로 간주하고 아무도 일도 하지 않을 것이라 예상하기 쉽다.
그러나 실제로는 `NullPointerException` 예외가 발생한다.

* `putIfAbsent()` 메서드는 기존 `null` 매핑을 새로운 값으로 대체한다. 따라서 `null` 매핑을 값의 부재와 동일하다고 간주하는 것처럼 보인다.
그러나 이 메서드는 `null`을 입력하면 새로운 `null` 매핑을 생성한다. 동일한 키로 두번 `putIfAbsent()`를 호출했을 때 두 번째는 아무 변화도 없을 것이다. 예상하기 쉽지만, 실제로는 맵이 변경되는 경우가 있다.

```java
var map = new HashMap<Stirng ,String>();
map.put("x", null);
map.putIfAbsent("x", null); // 매핑 추가
System.out.println(map);    // {x=null}
map.putIfAbsent("x", "1");  // 1로 대체
System.out.println(map);    // {x=1}
```
* 마지막으로 `computeIfAbsent()` 메서드는 기존에 담겨 있던 `null` 매핑을 교체한다.
그러나 `compute()`와 달리 리매핑 함수가 `null`을 반환해도 기존의 `null` 매핑은 삭제하지 않는다.


```java
var map = new HashMap<Stirng ,String>();
map.put("x", null);
map.computeIfAbsent("x",k -> null); // null 매핑 제거되지 않음
System.out.println(map);    // {x=null}
map.compute("x", (k, v) -> null);  // null 매핑 제거
System.out.println(map);    // {}
```

> 실수 방지 가이드
* 가장 좋은 방법은 모든 맵에서 `null` 값을 사용하지 않는 것이다. 꼭 필요하다면 `Optional` 등으로 래핑하라.
Map<String, Optional<String>>으로 `null` 값 대신 `Optional.empty()`를 저장하면 된다.
* 어쩔 수 없이 `null` 값을 사용해야 한다면, `containsKey()`, `getOrDefault()`, `put()` 처럼 `null` 값을 제대로 지원하는 가장 간단한 메서드만 사용한다.
* 맵을 직접 구현할 때는 `null` 값을 전면적으로 불허하라.