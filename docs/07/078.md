# List.remove() 직후 원소 생략
`List.remove(index)` 메서드로 인한 또 다른 버그 패턴은 리스트 인덱스를 순회하는 과정에서 등장한다.
다음과 같이 리스트의 특정 위치에서 마지막까지 원소를 제거하려는 시도가 좋은 예다.
```java
void trimHistory(List<?> history, int maxElements) {
    for (int i = maxElements; i < history.size(); i++) {
        history.remove(i);
    }
}
```
이 메서드는 `history` 리스트가 `maxElements` 보다 클 때 리스트 끝 쪽의 초과분을 제거하려 시도한다.
그러나 하나의 원소가 제거하면 그 다음 원소가 앞당겨진다는 점을 고려하지 않았고, 결과적으로 다음 번 제거 시 한 칸을 건너뛰게 되었다.

다음과 같이 특정 조건에 따라 원소를 제거하면 이 문제는 더욱 눈에 띄지 않을 것이다.
```java
for (int i = 0; i < data.size(); i++) {
    if (condition(data.get(i), i)) {
        data.remove(i);
    }
}
```

이 문제를 해결하려면 다음과 같이 `remove()` 호출 직후 루프 변수를 감소시켜야 한다.
```java
for (int i = 0; i < data.size(); i++) {
    if (condition(data.get(i), i)) {
        data.remove(i);
        i--;
    }
}
```
또는 다음과 같이 `remove()`를 호출하지 않을 때만 루프 변수를 증가시키는 방법도 있다.
```java
for (int i = 0; i < data.size(); i++) {
    if (condition(data.get(i), i)) {
        data.remove(i);
    } else {
        ++i;    
    }
}
```

> 실수 방지 가이드
* 루프 안에서 인덱스로 리스트 원소를 제거하는 작업은 신중하게 처리해야 한다. 이후의 원소가 앞당겨지므로 다음 번 원소를 건너뛸 위험이 있다.
* 컬렉션의 일부를 조건 없이 제거하려면 다음과 같이 `subList()`와 `clear()`를 활용하는 방법을 고려한다.
```java
if (history.size() > maxElements) {
    history.subList(maxElements, history.size()).clear();
}
```
`subList()`를 호출할 때는 `IndexOutOfBoundException`을 방지하기 위해 인수 범위를 먼저 검사해야 한다. `ArrayList` 등의 컬렉션은 루프를 통해 원소를 제거하는 것보다 이 방식이 더 빠르다.
대상 원소를 모두 한 번에 제거하기 때문이다.
* 코드의 의미를 변화시키지 않는 선에서, 다음과 같이 루프를 역방향으로 바꿔도 좋다.
```java
for (int i = data.size() - 1; i >= 0; i--) {
    if (condition(data.get(i), i)) {
        data.remove(i);    
    }    
}
```
역방향 루프는 원소를 건너뛰는 문제가 발생하지 않는다. 다음 번 탐색 원소가 이동하지 않고 유지되기 때문이다.
* 굳이 인덱스를 쓸 필요가 없는 상황이라면 다음과 같이 `removeIf()` 메서드를 사용하라.
```java
data.removeIf(this::condition);
```
* 단순한 원소 제거 이상의 작업을 루프에서 처리한다면, 인덱스 기반 루프 대신 이터레이터를 사용하라.
다음과 같이 이터레이터를 통해 원소를 제거하면 인덱스를 건너뛸 일이 없다.
```java
Interator<Object> it = data.iterator();
while (it.hasNext()) {
    Object next = it.next();
    if (condition) {
        it.remove();    
    }
}
```
* ListIterator를 사용하면 다음과 같이 인덱스를 내부적으로 유지하고 적절히 갱신할 수 있다.
또한 원소를 추가하거나 교체하는 등의 다른 작업도 처리할 수 있다.
```java
ListIterator<Object> iterator = list.listIterator();
while (iterator.hasNext()) {
    int index = interator.nextIndex();
    if (condition(next, index)) {
        iterator.remove();
    }
}
```
그러나 이렇게 하면 코드가 더 장황해지고 이해하기 어렵게 된다.
일반적으로 개발자들은 ListIterator를 기피하는 경향이 있다.