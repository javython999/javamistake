# 수정 불가 컬렉션의 수정 시도
자바에서 변경할 수 있는 컬렉션과 그렇지 않은 컬렉션이 있다.
또한 다음과 같이 특정 변경 작업만 허용하는 컬렉션도 있다.

* `Arrays.asList()`로 생성한 컬렉션은 `List.set()` 메서드 등으로 기존 원소를 수정할 수 있다. 그러나 원소를 추가허가나 제거할 수 없다.
* `Map.keySet()`으로 생성한 세트는 원소를 제거할 수 있지만 새로 추가할 수는 없다.
* `Collections.emptyList()`는 빈 리스트를, `Collections.singletonList()`는 원소가 1개인 리스트를 반환한다.
이들은 수정 불가 메서드지만 `sort()` 메서드를 호출하면 아무 일도 일어나지 않고 예외도 발생하지 않는다.
0개 또는 1개의 원소를 정렬할 필요가 없기 때문이다. 그러나 `List.of()`로 생성한 리스트에 `sort()` 메서드를 호출하면 원소가 0개 또는 1개라 해도
`UnsupportedOperationException`이 발생한다.

가변성은 자바 타입 시스템에 명시된 특성이 아니므로 컬렉션 타입만 보고 가변성을 판단할 수는 없다.
따라서 의도치 않게 수정 불가 컬렉션을 고치고 런타임 예외를 겪는 일이 종종 있다.
진짜 문제는, 변경 가능할 때도 있고 그렇지 않을 때도 있는 컬렉션이다.
예를 들어, 문자열을 트리밍하고 입력 배열에서 빈 문자열을 제거하는 다음 메서드를 살펴보자

```java
static List<String> sanitize(String[] input) {
    if (input.length == 0) {
        return Collections.emptyList();
    }
    
    List<String> list = new ArrayList<>();
    
    for (String s : input) {
        s = s.trim();
        if (!s.isEmpty()) {
            list.add(s);
        }
        return list;
    }
} 
```

이 메서드는 input 배열이 빈 배열이 아니면 가변 `ArrayList`를 반환한다.
그렇지 않을 때는 새로운 리스트를 할당하지 않고 공유 가능한 `emptyList()` 인스턴스를 반환하도록 최적화되어있다.
그러나 이 메서드를 호출하는 코드가 다음과 같다고 가정해보자.

```java
List<String> strings = sanitize(input);
strings.add("Custom...");
```

이 코드는 input 배열이 비어있지 않는 한 정상적으로 작동한다.
아마도 이 문제는 프로덕션까지 올라가고 나서야 발견될지도 모른다.

> 실수 방지 가이드
* 메서드가 반환한 컬렉션은 기본적으로 수정할 수 없다고 가정하고, 수정하려는 시도도 하지 않는다.
필요한 경우 복사본을 만들어 수정한다. 메서드에서 반환된 컬렉션을 가변 객체라고 간주하려면, 이 점이 API 문서에 명시적으로 드러나 있어야 한다.
* 메서드를 통해 반환할 컬렉션은 `Collections.unmodifiableXYZ()` 또는 `List.of()`, `List.copyOf()` 등의 컬렉션 팩토리로 래핑해 수정 불가 상태로 만드는 것이 좋다.
또한 코드 경로에 따라 수정 가능, 불가 컬렉션을 다르게 반환하지 않도록 주의한다.
스트림 API 사용 시, 수정 불가 컬렉션을 생성하는 컬렉터를 가급적 사용한다.
`Stream.collect(Collectors.toList())`는 사실상 수정 가능 컬렉션을 생성하지만 스펙에 명시된 작동 결과는 아니다.
수정 불가 리스트를 명시적으로 생성하려면 `toUnmodifiableList()` 메서드를 써야 한다.
또한 자바 16부터는 스트림 인터페이스에 `toList()` 메서드가 직접 추가되었으며 이를 통해 수정 불가 리스트를 생성할 수 있다.
* 메서드에 파라미터로 전달된 모든 컬렉션은 수정 불가 객체로 간주한다. 수정 가능한 컬렉션이 필요하다면 입력 인수 조건을 명시적으로 나타내야 한다.
공용 API에서는 전달 받은 파라미터를 수정하지 않는 것이 일반적인 관례다.
컬렉션 수정이 자연스럽게 인정되는 경우는 `Collections.suffle()` emddml zjffprtus dbxlfflxl aptjem Qnsdlek.
가끔 비공개 메서드에서 성능을 최적화시키기 위한 컬렉션을 수정할 때가 있다.
그러나 이러한 사례는 프로파일링을 통해 성능 개선 결과가 입증되어야 한다.

```java
public List<String> getData() {
    List<String> data = new ArrayList<>();
    fillPredefinedData(data);
    fillDataFromPlugins(data);
    fillUserSpecificData(data);
    return data;
}

private void fillPredefinedData(List<String> target) {...}
private void fillDataFromPlugins(List<String> target) {...}
private void fillUserSpecificData(List<String> target) {...}
```

이렇게 파라미터를 전달하고 수정하는 대신 다음과 같이 헬퍼 메서드를 통해 결과를 받는 것이 좋다.

```java
private List<String> getPredefinedData() {...}
private List<String> getDataFromPlugins() {...}
private List<String> getUserSpecificData() {...}
```

이렇게 하면 `getData()` 메서드에서 다음과 같이 `addAll()`을 사용할 수 있다.
```java
List<String> data = new ArrayList<>();
data.addAll(getPredefinedData());
data.addAll(getDataFromPlugins());
data.addAll(getUserSpecificData());
return List.copyOf(data); // 수정 불가 복사본 생성
```

또는 다음과 같이 스트림 API를 사용하는 방법도 있다.
```java
return Stream.of(getPredefinedData(), getDataFromPlugins(), getUserSpecificData())
        .flatMap(List::stream)
        .collect(Collectors.toUnmodifiableList());
```
처음보다 중간 객체들이 더 많이 생성되므로 성능적 비용은 늘어난다.
그러나 이 비용은 프로파일링 결과에서 거의 눈에 띄지 않을 정도로 미미할 것이다.
따라서 성급하게 최적화를 걱정할 필요가 없다.
반면 이제 헬퍼 메서드는 아무것도 수정하지 않으므로 재사용하고 테스트하기 훨씬 쉽다.

* 자신이 직접 만든 컬렉션만 수정한다. 일반적으로 이러한 컬렉션은 로컬 변수 또는 클래스의 private 필드에 저장된다.
* 구아바 라이브러리는 불변 컬렉션 타입 계층을 추가하는 방식으로 이 문제를 해결한다.
이를 테면 `Collection`, `Set`, `List` 인터페이스를 구현한 `ImmutableCollection`, `ImmutableSet`, `ImmutableList` 등의 추상 클래스가 있다.
이들의 구현체는 절대로 수정할 수 없으며 이들을 변경하는 메서드는 `deprecated`로 선언되어 컴파일러 경고와 IDE의 강조 표시를 이끌어낸다.
이러한 타입으로 필드나 메서드를 선언할 것을 권장한다.
구아바에 의존하지 않고 여전히 표준 JDK 컬렉션 타입을 사용하는 라이브러리가 아직 많다.
또한 구아바 컬렉션을 따로 쓰지 않는 레거시 컴포넌트가 프로젝트에 있거나, 개발자가 서드파티 라이브러리를 꺼리는 경우도 있다.
이러한 모든 예외 상황에도 불구하고 구아바 컬렉션은 사용할 만한 가치가 있다.
수정 불가 컬렉션을 수정하려 하는 버그를 줄일 수 있기 때문이다.