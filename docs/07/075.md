# HashMap 및 HashSet의 등장 순서 의존
컬렉션은 `for-each`, `stream()`, `배열변환`, 심지어 `toString()` 등의 다양한 방식으로 전체 내용을 가져올 수 있다.
이 때 대부분의 컬렉션은 원소의 순서를 정한다.
`TreeSet`은 자연순 또는 비교자가 순서를 결정하며 `LinkedHashSet`은 삽입순 접근 순서를 따른다.
그러나 `HashSet`이나 `HashMap` 등의 일부 컬렉션은 의도적으로 순서를 명시적으로 지정하지 않는다.
이렇게 된 이유는 자바 표준 라이브러리 개발자가 컬렉션을 더 효울적으로 구현하기 위해서였다.

가끔 개발자들은 이러한 전제를 잊거나 간과한다.
`HashSet`의 원소를 사용자 인터페이스에 표시하면 완전한 임의의 순서를 따라 나타나므로 사용자가 특정 대상을 찾기 어렵다.
만일 이러한 프로그램을 매우 적은 데이터로 테스트하고, 그중 3~4개의 원소가 논리적으로 나열되어 있다면 문제를 눈치채기 어려울 것이다.
또한 소수의 `Integer`로 구성된 `HashSet`은 마치 정렬된 것처럼 보인다는 점도 흥미롭다.

```java
HashSet<Integer> set = IntStream.range(0, 100)
        .boxed()
        .collect(Collectors.toCollection(HashSet::new));
System.out.println(set); // [0, 1, 2, 3, 4, 5, 6, 7, ...]
```
표준 OpenJDK의 HashSet 구현에서 이 숫자들은 순서대로 나타나고 계속 증가한다.
개발자는 이 데이터를 보고 이미 정렬되어 있으며 따로 조치할 필요가 없다고 생각할 수 있다.
하지만 이러한 현상은 상세 구현에서 비롯된 우연일 뿐이다.
이 데이터는 조금만 변경되어도 정렬이 흐트러진다.

```java
HashSet<Integer> set = IntStream.range(0, 100)
        .mapToObj(x -> x * 10)
        .collect(Collectors.toCollection(HashSet::new));
System.out.println(set); // [0, 770, 260, 520, 10, 780, 270, 530, 20, 790, ...]
```

가끔 개발자들은 테스트에서 `HashSet`의 순서에 의존한다.
예를 들어 `Set<String>`을 반환하는 `getSeasons()` 메서드가 있다고 가정해보자.
어떤 개발자는 다음과 같이 메서드 반환 결과를 문자열로 변환하고, 예상 결과 문자열과 단순 비교하는 식으로 테스트 할 것이다.

```java
@Test
public void testGetSeasons() {
    String result = getSeassons().toString();
    assertEquals("[Winter, Autum, Summer, Spring]", result);
}
```

만약 `getSeasons()`가 `HashSet`을 반환한다면 이 테스트는 `HashSet`의 구현에 따라 결과가 달라지므로 매우 불안정하다.
컬렉션 객체의 순서가 바뀌는 경우는 드물지만 실제로 변경될 가능성은 존재한다.
자바 버전이 8로 올라갔을 때 이미 그러한 전례가 있었다.
당시 자바 버전을 업그레이드 했던 많은 개발자가 테스트를 다시 작성해야 했다.

`getSeasons()` 메서드가 `Set.of()`의 불변 컬렉션 팩토리 메서드를 사용하면 상황은 더욱 흥미롭게 변한다.
불변 컬렉션 또한 순서를 보장하지 않지만, 한술 더 떠서 가상머신을 재시작 할 때마다 무작위로 순서를 섞는다.
개발자들이 행여 이러한 순서에 의존하지 않게 하기 위해서다.
따라서 한 번 실행한 결과를 기록하면 다음 번 실행에서 순서가 달라지므로 테스트가 실패할 가능성이 크다.
`Map.of()` 메서드가 반환하는 컬렉션도 같은 원리로 순서가 뒤바뀐다.

> 실수 방지 가이드
* 컬렉션을 순회할 때는 해당 컬렉션이 순서를 유지하는지, 또한 그 순서에 의미가 있는지 검토한다.
사용자 인터페이스에 표시할 데이터라면 순서가 명백히 중요하다. 이런 경우는 필요에 맞게 컬렉션을 정렬하라.
* 테스트에서 세트나 맵의 동등성을 검증할 때는 순서와 무관하게 내용을 직접 비교한다.
```java
@Test
public void testGetSeasons() {
    assertEquals(Set.of("Winter", "Autum", "Summer", "Spring"), getSeasons());
}
```
