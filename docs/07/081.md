# 이터레이터 계약 위반
`Collection`, `Map`, `Iterable`을 직접 구현할 때 커스텀 Iterator를 함께 구현하는 경우가 있다.
이터레이터의 문제는 매우 엄격한 계약에 비해 매우 특정한 방식으로만 사용된다는 것이다.
99%의 이터레이터가 하나의 방식으로 올바르게 작동하는 한, 잘못 구현된 곳이 있다 해도 쉽게 알아차릴 수 없다.
그러나 누군가 99% 이외의 방식으로 이터레이터를 사용하는 순간 프로그램은 망가질 것이다.

여기서 말하는 매우 특정한 방식이란 향상된 for 문 또는 `for-each` 문에 사용되는 이터레이터를 가리킨다.
향상된 for 문은 Iterable 인스턴스에서 `iterator()`를 호출하고 새로운 Iterator를 얻는다.
이후의 과정은 다음과 같다.

1. `iterator.hasNext()`가 false를 반환하면 반복을 마친다.
2. `iterator.next()`로 다음 원소를 가져온 다음 반복문의 변수에 할당 한다.
3. 루프 본문을 실행한다.
4. 1단계로 돌아간다.

이것이 전부다. 이 시나리오를 지원하는 이터레이터는 향상된 for 문에서 잘 작동한다.
특히 이러한 반복문은 다음과 같이 일을 절대 하지 않는다는 특징이 있다.

* `iterator.next()` 사이에서 `iterator.hasNext()`를 두 번연속 호출함
* `iterator.hasNext()` 사이에서 `interator.next()`를 두 번연속 호출함
* `iterator.hasNext()` 호출 이전에 `interator.next()`를 호출함
* 남은 원소가 없을 때 `iterator.next()`가 던지는 `NoSuchElementException`을 `catch`하고 처리함

이러한 일들은 향상된 for 루프에서 벌어지지 않지만, 모두 이터레이터가 실제로 할 수 있는 유효한 작업들이다.
`Collections.min()`, `Collections.max()` 등의 일부 컬렉션 유틸리티 메서드는 실제로 이러한 작업을 수행한다.
이들은 컬렉션에서 최소 또는 최대 원소를 찾을 때 `hasNext()` 호출 이전에 `iterator.next()`를 시작하며, 입력 컬렉션이 비어 있을 때는 이터레이터에서 직접 `NoSuchElementException`을 던진다.

일부 이터레이터는 `hasNext()`가 `next()` 보다 먼저 호출될 것이라는 예상에 근거해 `hasNext()` 안에서 다음 값을 준비하기도 한다.
예를 들어, 0부터 max 미만의 숫자를 생성하는 Collection이 있다고 가정해보자.
이러한 컬렉션은 다음과 같이 `AbstractCollection`을 상속하고 이터레이터를 제공하는 식으로 구현할 수 있다.

```java
static Collection<Integer> range(int max) {
    if (max < 0) {
        throw new IllegalArgumentException();
    }

    return new AbstractCollection<>() {
        public int size() {
            return max;
        }

        @Override
        public Iterator<Integer> iterator() {
            return new Iterator<Integer>() {
                int cur = -1;
                
                @Override
                public boolean hasNext() {
                    return ++cur < max;
                }

                @Override
                public Integer next() {
                    return cur;
                }
            };
        }

        @Override
        public int size() {
            return 0;
        }
    };
}
```
이 구현은 분명히 Iterator 계약을 위반한다.
`hasNext()`는 상태를 변경하고 `next()`는 `NoSuchElementException`을 던지지 않는다.

그럼에도 불구하고 향상된 for 루프에서 사용하면 다음과 같이 잘 작동한다.
```java
for (int value : range(10)) {
    System.out.println(value);    
}
```
이 루프는 예상대로 0부터 9까지의 숫자를 출력한다.
이렇듯 표준화된 사용 양식에서 잘 작동하면 이터레이터가 잘못 구현된 부분을 간과하게 된다.
비슷한 방식으로 취약한 이터레이터가 프로덕션 코드에서 자주 발견되는 이유는 이 때문이다.
다음과 같이 `Collections.min()`을 호출하면 문제가 바로 드러난다.

```java
System.out.println(Collections.min(range(10)));  // -1 출력
```
> 실수 방지 가이드
* 커스텀 이터레이터는 철저히 테스트한다.
이터레이터 계약을 테스트하는 평범한 유틸리티 메서드는 그리 어렵지 않게 만들 수 있다.
이 유틸리티는 이터레이터와 예상 결과를 비교하며 반복 실행 결과를 검증한다.
또한 이 과정에서 `next()`를 호출하지 않은 채 `hasNext()`를 여러 번 호출하고, 반대로도 테스트할 수 있어야 한다.
반복이 올바르게 종료되는지도 테스트 대상이다. `hasNext()`가 `false`를 반환하면 이후의 모든 `hasNext()` 호출은 계속해서 `false`를 반환해야 하고,
이후 `next()` 호출은 `NoSuchElementException`을 던져야 한다.
* 꼭 그래야 할 이유가 없는 한, `hasNext()` 메서드 안에서 이터레이터의 내부 상태를 변경하지 않는다. 구현이 복잡해지고 버그가 발생하기 쉽다.
* 가급적이면 이터레이터를 직접 구현하지 않는다. 개발자에게 필요한 이터레이터는 대부분 JDK와 유명 라이브러리 어딘가에 구현되어있다. 약간의 성능 오버헤드만 감수한다면 자바 Stream도 Iterator를 생성할 수 있다.
```java
return IntStream.range(0, max).iterator();
```
마찬가지로 BufferedReader로 한 줄씩 읽는 이터레이터도 직접 구현할 필요가 없다.
```java
return reader.lines().iterator();
```