# 가변 객체를 키로 사용
맵 키 또는 세트 원소에 저장했던 객체를 변경하면 컬렉션이 손상된다.
특히 이전에 추가했던 객체를 찾지 못하거나 제거하지 못하게 된다는 점이 위험하다.

```java
Set<List<String>> set = new HashSet<>();
List<String> list = new ArrayList<>();
set.add(list);
list.add("Value");
System.out.println(set.contains(list)); // false
```
리스트를 세트에 추가한 뒤 리스트 내용을 변경하면 리스트의 해시코드도 변경된다.
그러나 객체가 저장되는 버킷 인덱스 객체가 햇 ㅣ테이블에 추가되던 시점의 해시코드를 바탕으로 결정된다.
이후 `set.contains(list)`를 실행하면 바뀐 해시코드로 버킷을 검색하며, 그곳에는 해당 객체가 존재하지 않는다.

내용 기반 비교 메서드인 `compareTo()`가 있음에도 불구하고 동일성 기반인 `equals()`와 `hashCode()` 메서드를 사용하는 객체도 있다.
가령 `StringBuilder`는 자바 11에 와서야 `Comparable` 인터페이스를 구현하도록 개선되었다.
다시 말해 `equals()`와 `compareTo()` 구현이 일관적이지 않다는 뜻이다.
`equals()`는 서로 다른 객체를 비교할 때 무조건 `false`를 반환하지만 `compareTo()`는 객체의 내용을 비교한다.
그렇다면 `StringBuilder` 객체를 `HashMap` 키나 `HashSet` 원소로 사용한 이후에 수정하면 어떻게 될까?
이러한 시도는 매우 위험한 상황을 자초하는 행동이다.
자바 8부터 `HashMap`과 `HashSet` 구현은 특정 버킷에서 레드-블랙 트리로 전활될 수 있으며 해시 충돌이 늘어나면서 `compareTo()`에 의존한다.

```java
    public static void main(String[] args) {
        Set<StringBuilder> set = new HashSet<>();

        for (int count = 0; count < 40; count++) {
            set.add(firstBucketStringBuilder());
        }

        int[] hashCodes = set.stream()
                .mapToInt(StringBuilder::hashCode)
                .sorted()
                .toArray();

        StringBuilder sb = Stream.generate(StringBuilder::new)
                .filter(b -> Arrays.binarySearch(hashCodes, b.hashCode()) >= 0)
                .findFirst()
                .get();

        set.add(sb);
        System.out.println(set.contains(sb));

        sb.append("b");
        System.out.println(set.contains(sb));
    }

    static StringBuilder firstBucketStringBuilder() {
        while (true) {
            StringBuilder sb = new StringBuilder("a");
            int hc = sb.hashCode();
            if ((((hc ^ (hc >>> 16)) & 0x3F) == 0)) {
                return sb;
            }
        }
    }
```
`firstBucketStringBuilder()`는 OpenJDK의 `HashMap` 구현(HashSet 내부 코드)을 역이용한다.
이러한 방식으로 해시 테이블이 작을 때 첫 번째 버킷으로 저장되도록 StringBuilder 객체를 생성하고 있다.
이렇게 생성한 40개의 StringBuilder 객체를 `HashSet`에 추가하면 레드-블랙 트리 구현으로 `HashSet`를 강제 전환할 수 있다.
다음으로, 기존과 동일한 해시코드를 지닌 StringBuilder 객체를 생성하고 이를 sb 변수로 저장한다.
이제 sb를 `HashSet`에 추가한 다음 값을 변경하면 `HashSet`은 더이상 해당 객체를 찾지 못하게 된다.
따라서 `contains` 메서드는 `false`를 반환한다.
물론 이 예시는 수작업으로 만들었다. 이 정도로 구체적인 해시 충돌 상황은 의도적으로 만들지 않는 한 발생하기 어려울 것이다.
그러나 일단 실제로 발생한다면 도저히 재현할 수 없는 버그가 될 가능성이 높다.

> 실수 방지 가이드
* 가변 객체를 맵의 키나 세트 원소로 사용하지 않는다. 어쩔 수 없이 사용했다면 해당 맵 또는 세트의 수명이 유지되는 동안 객체를 변경하지 않는다.
* 자바의 `java.uitl.Date` 같은 레거시 가변 객체를 코드베이스에서 제거하고, 가능하면 신형 불변 객체로 대체 한다.
* 가변 객체를 맵의 키나 세트 원소로 사용해야 한다면 `java.util.IdentityHashMap` 구현이 해당 용도에 더 접합하다.
이 맵은 `equals()` 및 `hashCode()` 구현에 관계없이 객체를 참조로 비교하므로 객체 내용을 바꿔도 맵은 기존과 똑같이 작동한다.
세트의 경우 `Collections.newSetFromMap(new IdentityHashMap<>())`을 쓰면 된다.
* 가변 객체의 `equals()`, `hashCode()`, `compareTo()` 메서드가 객체 내용에 의존하지 않도록 정의하면 `HashSet` 및 `HashMap`에 안전하게 사용할 수 있다.
* `HashMap`의 키나 `HashSet`의 원소로 객체를 사용할 때, 객체의 `compareTo()` 구현과 `equals()` 구현이 일관성을 유지하는지 확인한다.
이를 준수하지 못하면 해시코드가 충돌할 때만 매우 드물게 문제를 일으키는 버그가 생길지도 모른다.
* 핫스팟 JVM은 기본 해시코드 알고리즘을 재정의할 수 있다. 공개적으로 알려지지는 않았지만, 다음과 같이 커맨드라인 옵션을 주면 항상 해시코드가 1로 계산되도록 강제할 수 있다.
```
java -XX:UnlockExperimentalVMOptions -XX:hashCode=2
```
* 식별 해시코드를 모두 같게 만들어도 JVM 스펙을 위반하는 것은 아니다. 그러나 성능은 영향을 받는다. 따라서 이러한 조각으로 애플리케이션을 테스트하는 것은 나름의 의미가 있다.
식별 해시코드 분포에 의존하는 코드를 파악할 수 있기 때문이다.
