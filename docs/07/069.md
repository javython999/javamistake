# 관련 없는 객체 타입 검색
파라미터화된 타입이 자바에 도입되기 전까지, 컬렉션과 맵에 객체를 추가할 때 `Object` 이상으로 구체적인 타입을 지정할 수 없었다.
제네릭이 도입된 이후로는 컬렉션에 원소를 추가하는 모든 메서드가 해당 컬렉션의 타입만 허용하도록 제한되었다.
하지만 원소를 검색하거나 제거하는 메서드는 대부분이러한 제한이 적용되지 않았다.
여기에는 다음과 같이 개별 원소를 다루는 메서들이 포함된다.

* Collection 인터페이스: contains(Object), remove(Object)
* List 인터페이스: indexOf(Object), lastIndex(Object)
* Map 인터페이스: containsKey(Object), containsValue(Object), get(Object), getOrDefault(Object, v), remove(Object), remove(Object, Object)

또한 Collection 인터페이스의 containsAll(), removeAll(), retainAll() 메서드는 모두 컬렉션 객체를 인수로 받는다.
이러한 컬렉션 타입에는 아무런 제한도 없다.

따라서 컬렉션의 타입이 지정되어 있다 해도, 위와 같은 메서드를 호출하면 해당 컬렉션과 무관한 타입의 객체 또는 그러한 객체를 담긴 컬렉션을 인수로 전달 할 수 있다.
더 큰 문제는, 자주 쓰이는 컬렉션이나 맵 타입에 이런 일이 벌어져도 즉각적인 런타임 에러가 발생하지 않는다는 점이다.
검색 메서드는 긎 ㅓ빈 결과를 반환하고, 제거 메서드는 아무것도 제거하지 않으며, retainAll()메서드는 아무것도 유지하지 않는다.
이러한 오류는 시간이 지나야만 감지되며 별다른 장애물 없이 프로덕션 환경에 유입된다.

```java
Set<File> allowedFiles = new HashSet<>();

boolean isAllowed(Path filePath) {
    return allowedFiles.contains(filePath);
}
```

이 코드는 파일 경로를 나타내는 클래스를 java.nio.file.Path로 마이그레이션했다.
그러나 allowedFiles 컬렉션은 여전히 구형 java.nio.File 객체를 담고 있으므로 contains()은 무조건 false를 반환할 수 밖에 없다.
마찬가지로, 파일 객체와 파일 경로 문자열 객체를 혼용하는 일도 흔하다.
숫자를 담는 컬렉션도 비슷한 문제를 일으킨다. 박싱된 숫자를 담는 컬렉션에 원시 타입 숫자를 전달하면 묵시적으로 타입이 변환된다.
이 경우, 변환된 숫자 타입이 컬렉션 타입과 불일치 할 수 있으므로 주의해야 한다.

```java
void processList(List<Short> values, short pivot) {
    if (values.contains(pivot)) {  // 판단 가능
        ...
    } else if (values.contains(pivot + 1)) { // 판단 불가능 
        ...
    }
}
```
이 코드는 Short 타입 리스트에 pivot 또는 pivot + 1이 담겨 있는지 검사한다.
pivot + 1은 컴파일할 때 확장 변환되어 int 타입이 된다.
contains() 메서드 인수는 Object이므로 pivot + 1은 Integer로 자동 박시된다.
Short 타입 컬렉션에는 Integer 값을 넣을 수 없으므로 두 번쨰 조건은 절대 true가 될 수 없다.

> 실수 방지 가이드
* 컬렉션과 맵의 검색 메서드와 제거 메서드가 무언가를 찾거나 제거할 때 각각의 실행 경로를 유닛 테스트로 검증한다.
* 박싱된 원시 타입 컬렉션을 지양하고 FastUtil 등의 라이브러리를 원시 타입의 대용품으로 사용한다.
이 들은 훨씬 빠르고 메모리도 덜 쓰며 원시 값을 그대로 처리하는 메서드를 제공한다. 이들을 쓰면 Integer와 Short를 비교하는 문제 상황에 처할 일이 없다.
서드파티 라이브러리가 없다 해도 Byte와 Short 타입 컬렉션은 무조건 사용하지 않는 것이 좋다. Integer 컬렉션과 비교할 때 메모리 또는 성능 면에서 이득을 볼 가능성은 낮다.
