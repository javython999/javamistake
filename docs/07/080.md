# Map.computeIfAbsent()의 동시 수정
자바 8은 Map 인터페이스에 `computeIfAbsent()`, `computeIfPresent()`, `compute()`, `merge()` 등의 여러 새로운 메서드를 도입했다.
이들을 이용하면 맵에서 기존 값의 존재 여부에 따라 매핑을 갱신할 수 있다.
갱신될 값은 사용자 제공 함수를 통해 계산된다.

자바 8 이전에는 다음과 같은 방식으로 다중맵에 새로운 원소를 추가 했다.
```java
static void addToMultiMap(Map<String, List<String>> map, String key, String value) {
    List<String> list = map.get(key);
    if (list == null) {
        list = new ArrayList<>();
        map.put(key, list);
    }
    list.add(value);
}
```

이제는 `computeIfAbsent()` 덕에 다음과 같이 한 줄의 코드로 처리할 수 있다.
```java
static void addToMultiMap(Map<String, List<String>> map, String key, String value) {
    map.computeIfAbsent(key, k -> new ArrayList<>()).add(value);
}
```
이 API 메서드는 코드를 단축하는 역할뿐만 아니라 성능도 최적화하도록 설계되었다.
`get()`과 `put()`을 따로 호출하면서 해시 테이블이나 이진 트리 등의 맵 데이터 구조에서 키를 두 번 찾게 된다.
그러나 `computeIfAbsent()`를 호출하면 검색을 한 번만 수행하며, 해당 키가 존재하지 않을 경우 새로 추가될 위치까지 알아낸다.
이렇든 신규 메서드는 구현이 최적화되었으므로 성능을 높이는 효과를 낸다.
`HashMap`은 자바 8부터, `TreeMap`은 자바 15부터 최적화된 구현을 제공한다.

그러나 이러한 최적화에는 대가가 따른다.
사욪아 제공 함수는 키 검색과 삽인의 중간 단계에서 호출된다.
만약 이 함수가 맵 자체를 수정하게 되면 키가 삽입될 위치 또한 어긋난다.
이 문제는 자바 8이 출시되고 나서야 발견되었다. 
따라서 자바 8에서는 이러한 동시 수정이 `HashMap`을 손상시킬 수 있다.
자바 9부터는 `HashMap`에서 동시 수정을 감지하며 `computeIfAbsent()` 등의 메서드에서 `ConcurrentMidificationException` 예외를 던진다.

> 실수 방지 가이드
* `computeIfAbsent()` 또는 유사 메서드를 사용할 때는 인수로 사용한 함수가 대상 맵을 직접 또는 간접적으로 수정하고 있는지 항상 확인해야 한다.
확실치 않으면 `get()`/`put()` 시퀀스를 활용하는 것이 좋다.
* 자바를 최신 버전으로 높일 때는 `computeIfAbsent()` 호출 코드를 재확인한다.
자바 15부터 `TreeMap.computeIfAbsent()` 메서드는 `ConcurrentModificationException` 예외를 던지기 시작한다.
따라서 기존에 잘 작동하던 코드가 갑자기 작동하지 않는 겨우도 있다.
설령 Map 구현체가 동시 수정을 감지하지 않는다 해도 `computeIfAbsent()`에서 동시 수정이 일어나는 것 자체가 잘못이다.
메서드가 설명서에서 이를 명백히 금지하고 있기 때문이다.
* 한 번에 여러 가지를 검증하는 테스트는 신중하게 만들어야 한다.
통상적으로, 좋은 테스트는 배치, 실행, 검증 패턴을 따르며, 검증 단계에서는 아무것도 수정하지 않는 것을 원칙으로 한다.

