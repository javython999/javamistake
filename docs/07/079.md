# Collection.removeIf() 내부의 컬렉션 조회
`removeIf()` 메서든느 자바 8에서 `java.util.Collection` 클래스에 추가되었다.
이 메서드는 프레디케이트를 통해 일부 컬렉션 원소를 제거 한다.
프레디케이트 내부에서 원본 컬렉션을 직접 변경하려는 시도는 바람직하지 않다.
일반적으로 `removeIf()` 구현은 이러한 변경 시도를 감지하고 `ConcurrentMidificationException`예외를 일으킨다.
이 메서드에 숨은 또 다른 함정은 프레디케이트 내부에서 원본 컬렉션을 조회하려는 시도에 있다.
언뜻 보면 이러한 시도는 전혀 위험해 보이지 않는다.
그러나 프레디케이트 호출과 리스트 수정이 어떤 순서로 진행되는지 명시적으로 규정하는 스펙은 없다.
이러한 어떤 컬렉션은 먼저 수정되기도 하고, 어떤 컬렉션은 나중에 수정된다.

순서와 무관한 숫자 컬렉션이 있다고 가정해보자.
이 컬렉션에 존재하는 일련의 인접 숫자들 중 가장 작은 숫자만 남기려 한다.
예를 들어 1, 2, 3, 8, 9, 10, 13, 14가 담긴 컬렉션은 (1, 2, 3), (8, 9 10), (13, 14) 라는 세 종류의 인접 숫자 집합으로 나눌 수 있다.
이들 중 1, 8, 13만 남기고 나머지는 모두 제거해야 한다.
이는 다음과 같이 `removeIf()`를 활용하기 좋은 시나리오 처럼보인다.

```java
static void process(Collection<Integer> c) {
    c.removeIf(x -> c.contains(x - 1));
    System.out.println(c);
}
```

이 코드는 특정 숫자의 바로 앞에서 있는 숫자를 컬렉션에서 검색하고 제거한다.
아직까지는 아무 문제 없어 보인다. 이제 이 메서드를 다음과 같이 테스트 해보자.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 8, 9, 10, 13, 14);
process(new ArrayList<>(numbers));
```
실행 결과, 정확하게 `[1, 8, 13]`이 출력된다. 이제 여기에 다른 컬렉션 타입을 적용해보자.
```java
process(new TreeSet<>(numbers));
```
이 코드를 실행하면 이전과 달리 `[1, 3, 8, 10, 13]`이 출력된다.
두 호출 결과가 달라진 이유는 `ArrayList`와 `TreeSet`에 구현된 각각의 `removeIf()`를 통해 설명할 수 있다.
`ArrayList`의 `removeIf()`는 컬렉션의 모든 원소에 대해 프레디케이트를 확인하고 그 결과를 취합해서 한 번에 적용한다.
이 작동방식은 많은 원소를 삭제할 때 성능을 최적화 시키는 효과를 낸다.
변경될 원소들이 원래의 배열을 기준으로 한 번만 움직이기 때문이다.

반대로, `TreeSet`은 이러한 최적화로 얻을 이득이 없기에 기본 구현 그대로 `removeIf()`를 실행한다.
따라서 프레디케이트가 `true`를 반환할 때마다 `iterator.remove()`를 호출하게 된다.
결과적으로 `ArrayList`는 원래의 컬렉션 상태에서 프레디케이트를 적용하면 반면 `TreeSet`은 반복 실행 과정에서 삭제된 원소에 프레디케이트를 적용하지 못한다.
이 결과는 컬렉션의 종류뿐만 아니라 자바 버전에 따라 달라진다.
예를 들어 다음은 `ArrayDeque`를 적용한 코드다.
```java
process(new ArrayDeque<>(numbers));
```
이 코드는 자바 8에서 `[1, 3, 8 ,10, 13]`을 출력하지만, 자바 9 이상에서는 `[1, 8, 13]`을 출력한다.
자바 9부터 `ArrayDeque` 클래스도 `ArrayList`처럼 최적화 구현이 적용되었기 때문이다.
순회 과정에서 생기는 컬렉션의 변화가 프레디케이트에 반영되어야 하는지는 명시적인 스펙으로 규정되어 있지 않다.
따라서 이러한 구현에 의존하지 않는 것이 좋다.

> 실수 방지 가이드
* `removeIf()` 프레디케이트 내부에서 원본 컬렉션을 조회하지 않는 것이 좋다.
컬렉션 순회에 따른 변화와 프레디케이트의 반영 여부는 명시적으로 결정되어 있지 않기 때문이다. 또한 `ConcurrentModificationException`을 탐지하는 것도 도움이 되지 않는다. 동시 수정에 관한 문제가 아니기 때문이다.
* 가급적이면 원래 컬렉션을 수정하는 대신 새로운 컬렉셔늘 생성한다. 
```java
static List<Integer> process(Collection<Integer> c) {
    return c.stream().filter(x -> !c.contains(x - 1)).toList();
}
```
이 코드는 항상 컬렉션의 원본 상태를 관찰하게 된다. 원본 컬렉션을 전혀 변경하지 않기 때문이다.