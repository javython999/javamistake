# 순회 도중 수정하기
원칙적으로, 동시성이 없는 자바 컬렉션은 이터레이터를 사용하지 않는 이상 순회 도중에 변경할 수 없다.
이러한 원칙에 위배되는 변경 시도가 감지되면 통상적으로 런타임시 `ConcurrentModificationException` 예외가 일어나며 실행이 중단되다.
가령 다음 코드를 실행하면 예외가 발생한다.

```java
List<String> list = new ArrayList<>(List.of("a", "b", "c"));
for (String s : list) {
    System.out.println(s);
    if ("b".equals(s)) {
        list.add("x");    
    }
}
```
자바의 표준 컬렉션은 동시 수정을 감지하는 용도로 `modCount`라는 정수필드를 둔다.
이 필드의 값은 컬렉션이 수정될 때마다 증가한다.
이터레이터가 생성되면 현재 `modCount` 값이 이터레이터 인스턴스에 복사되며, 이후 `next()` 메서드가 호출 될 때마다 인스턴스의 `modCount` 복사본과
원본 `modCount` 값을 비교하고, 차이가 있을 경우 예외를 던진다.

이렇나 작동 방식을 `fail-fast behavior`라고 부른다.
이 명칭은 이터레이터가 동시 수정을 감지하자마자 순회가 중단되는 의미를 담고 있다.
변경 사항을 제대로 처리할 수 있을지 알 수 없는 상황에서는 순회를 이어갈 수 없기 때문이다.

반면, 인덱스를 사용한 반복문은 이터레이터가 없으므로 예외가 발생하지 않는다.
```java
List<String> list = new ArrayList<>(List.of("a", "b", "c"));
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
    if ("b".equals(list.get(i))) {
        list.add("x");
    }
}
```
실수 `018 구형 for 루프 오류`에서 설명했다시피, 종래의 for 루프는 매우 취약하며 다양한 방식으로 문제를 일으킨다.
따라서 보통 `for-each` 루프를 권장하는 편이다.
그러나 이번 경우는 인덱스 루프가 정상적으로 완료되고 `for-each`루프는 예외를 던진다.
이번 절의 예시 코드는 동시 수정되는 부분이 뚜렷하게 드러나지만 현실의 코드는 이보다 더 복잡할 것이다.
따라서 인덱스 루프를 무작정 `for-each` 루프로 대체하면 프로그램이 잘못 작동하게 될 위험이 있다.

또한 이터레이터를 썼지만 `ConcurrentModificationException` 예외가 발생하지 않는 경우도 있다.
```java
for (String s : list) {
    System.out.println(s);
    if ("b".equals(s)) {
        list.remove("a");    
    }
}
```
`modCount`를 비교하는 곳은 `next()` 메서드 뿐이다.
`hasNext()` 메서드는 그저 지금 까지 처리한 원소 개수가 리스트 크기에 도달했는지만 확인한다.
두 번째 반복 이후 원소를 제거하면 리스트 크기가 2로 줄어들고 지금까지 반복 횟수와 같아지므로 루프는 문제없이 종료된다.
이러한 작동 과정은 정확한 스펙으로 규정되어 있지 않으므로 앞으로의 자바 버전이나 다른 컬렉션 구현에서 예외를 일으킬 가능성도 있다.
확실한 것은 `ConcurrentModificationException` 예외가 무조건 발생하는 것은 아니라는 것이다.

> 실수 방지 가이드
* `ConcurrentModificationException`을 적이 아닌 친구로 대한다. 이 예외는 프로그램에 버그가 있다는 신호이며, 경고를 보는 즉시 문제를 해결해야 한다.
`ConcurrentModificationException` 예외를 포착하고 특정한 방식으로 처리하려 하면 안 된다.
이 예외를 합리적으로 감수할 방법은 없으며, 발생 사실을 알리고 해당 작업을 종료하는 것이 유일한 길이다.
* `forEach()` 메서드 또는 스트림 API의 컬렉션 탐색은 모두 일종의 반복문이다. 따라서 `forEach()` 람다 함수와 스트림 작업 도중에 컬렉션을 수정하면 안된다.
* IDE가 인덱스 기반 루프를 `for-each` 루프로 대체하라고 권장해도 무조건 수용하지 말고 신중하게 검토해야 한다. 루프 과정에서 컬렉션이 수정되고 있다면 루프 교체로 인해 프로그램이 중단되는 경우가 생길 수 있다.
* 순회 도중 컬렉션을 변경해야 한다면, 그러한 변화가 순회 과정에 반드시 영향을 주어야 하는지 검토해야 한다. 그렇지 않은 한 다음과 같이 원본 컬렉션을 복사해서 순회하는 것이 좋다.
```java
for (String element : new ArrayList<>(originCollection)) {
    ...
}
```
* 순회 도중 컬렉션이 드물게 수정된다면 `CopyOnWriteArrayList`를 사용할 수 있다.
이 컬렉션은 주로 스레드 안전을 확보하기 위해 쓰지만, 단일 스레드 환경에서도 쓸모가 있다. 루프 안에서 컬렉션을 변경해도 이터레이터 생성 당시의 컬렉션 상태를 항상 확인할 수 있기 때문이다.
정확히 말하자면, 이터레이터는 원본 컬렉션을 참조하며 컬렉션을 수정할 때마다 내부 배열이 새로 복사된다. 따라서 원본 컬렉션 전체를 복사하는 것보다 이 방법이 빠른 경우가 있다.
그러나 그 속도 차이를 명확히 비교하려면 루프 처리량을 벤치마킹해야 한다.