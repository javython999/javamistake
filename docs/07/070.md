# 단일 객체와 컬렉션 혼합
컬렉션 API 메서드 중 일부는 단일 객체를, 또 다른 일부는 전체 컬렉션을 입력받는다.
이들은 이름이 비슷해서 헷갈리기 쉽다.
단일 객체용 메서드를 써야 할 곳에 컬렉션용 메서드를 스면 타입이 호환되지 않으므로 컴파일러가 허용하지 않는다.
하지만 이와 반대의 실수는 그렇지 않다.
`contains()`와 `remove()` 메서드의 인수는 `Object` 타입이다.
따라서 이들에게 컬렉션을 전달해도 컴파일러는 그대로 허용한다.
나머지 메서드도 List<Object> 또는 raw 타입 List에서 호출하면 문제를 일으키기 쉽다.

가끔 프로그래머들은 상위 타입이 다른 원소들을 같은 리스트에 저장하곤 한다.
가령 `Integer`와 `String` 객체를 한 리스트에 넣는다고 가정해보자.
물론 이 두 클래스도 `Comparble` 또는 `Serializable`처럼 공통으로 구현한 인터페이스가 있긴 하다.
그러나 객체를 비교하거나 직렬화하는 용도가 아닌 한, List<Comparable<?>> 또는 List<Serializable>로 리스트를 선언하기는 어쩐지 어색하다.
그래서 많은 개발자들은 List<Object> 형태로 리스트를 쓴다.
이러한 컬렉션은 서로 관련 없는 객체들을 무방비 상태로 받아들이므로 상당히 위험하다.
특히 컬렉션 자체를 하나의 원소로 추가하는 것도 가능하다.

```java
List<Object> createList() {
    List<Object> result = new ArrayList<>();
    result.add(getInitalValue());
    result.add(getPredefinedValues());
    result.add(getUserSpecifiedValues());
    return result;
}

private Object getInitalValue() {...}
private List<Object> getPredefinedValues() {...}
private List<Object> getUserSpecifiedValues() {...}
```

`result`는 세 곳에서 온 값으로 채워진다.
`addAll()`을 써야 할 곳에서 `add()` 메서드를 사용하는 실수를 저질렀다.
컴파일러는 이 실수에 대해 아무런 이의를 제기하지 않는다.
전적으로 합법적인 코드이기 때문이다.

불변 복사본을 만들 때도 이와 비슷한 문제가 생기기 쉽다. 
```java
List<Object> createList(boolean userSpecifiedOnly) {
    if (userSpecifiedOnly) {
        return List.of(getUserSpecifiedValues());
    }
}
```
`List.copyOf()`를 써야할 곳에서 실수로 `List.of()`를 호출했다.
이러한 실수 이후 무슨 일이 벌어질지는 해당 컬렉션을 어떻게 조회하는가에 달려 있다.

```java
void processList(List<Object> list) {
    for (Object element : list) {
        if (element instanceof Integer number) {
            processNumber(number);
        }
        if (element instanceof String string) {
            processString(string);
        }
    }
}
```
컬렉션 원소 타입을 확인하면 실수로 잘못 들어간 원소들은 완전히 무시된다.

컬렉션 내부의 원소 타입이 제한적이어야 할 때는, 잘못된 타입이 발견될 경우를 대비해 다음과 같이 예외를 던지면 좋다.
```java
void processList(List<Object> list) {
    for (Object element : list) {
        if (element instanceof Integer number) {
            processNumber(number);
        } else if (element instanceof String string) {
            processString(string);
        } else {
            throw new IllegalArgumentException("Unexpected element: " + element);
        }
    }
}
```
이렇게 예외가 발생하도록 조치해두면 테스트 기간중 문제를 발견할 가능성도 높아진다.
올바르게 생성된 리스트도 스트림 API를 잘못 쓰면 문제가 생길 수 있다.
예를 들어 리스트를 스트리밍할 때 `list.stream()` 대신 `Stream.of(list)`를 사용하면 다음과 같은 실수가 벌어진다.
```java
void processNumbersOnly(List<Object> list) {
    Stream.of(list)
            .filter(e -> e instanceof Number)
            .forEach(num -> processNumber((Number) num));
}
```
이 코드의 작성자는 리스트에서 숫자만 골라 `processNumber()` 메서드에 전달하려 했다.
그러나 결과적으로 리스트의 모든 원소 대신 리스트 자체를 하나의 원소로 스트리밍 하고 있다.
`e` 파라미터의 추론타입은 `Object`가 아닌 `List<Object>`다.
`List` 구현체가 `Number` 클래스를 확장했을 가능성은 거의 없으므로 이 코드는 아무런 일도 하지 않는다.

> 실수 방지 가이드
* 원시 타입을 사용하지 않는다. 타입 인수 없이 List를 선언하면 강한 타입형 언어가 지닌 모든 장점을 포기하는 것이나 다름 없다. 또한 코드는 훨씬 더 에러에 취약해진다.
* `Object` 타입은 가급적 사용하지 않는다. 특히 컬렉션에 `Object`를 담으면 여러 모로 좋지 않다.
서로 다른 타입을 함께 저장해야 한다면 이들을 래핑하는 방법을 찾아보는 것이 좋다.
가령 정수와 문자열이 함께 담긴 구조를 자바 16의 `record`로 간단히 표현하면 다음과 같다.
```java
interface Entry {}
record IntEntry(int value) implements Entry {}
record StringEntry(String value) implements Entry {}

List<Entry> entrys = new ArrayList<>();
```
이제 List<Entry>를 안전하게 사용할 수 있으며 해당 타입 구조와 관련없는 데이터는 컴파일러가 차단할 것이다.
자바 17부터 인터페이스를 `sealed`로 선언하고 외부 구현을 금지할 수 있어 코드가 더욱 견고해진다.
* 프로젝트에 정의된 다양한 타입을 균일하게 처리하려면 공통 인터페이스를 선언하고 구현하라.
이렇게 하면 `Object` 타입을 쓸 필요가 없고 코드가 전반적으로 개선되는 효과가 있다.
처음에는 공통 인터페이스 안에 아무것도 없겠지만 나중에 구현 클래스 메서드 일부를 인터페이스로 손쉽게 끌어올릴 수 있다.
또한 `instanceof`로 타입을 검사하는 곳이 줄어들어 코드가 간결해지고 가독성이 향상된다.
* 타입에 따른 처리 조건을 `instanceof`로 연이어 검사할 때는 명시적인 else 분기를 두고 예외를 던지도록 한다.
자바 21에 도입된 `sealed` 타입 구조와 철저한 switch 구문을 쓰면 이 과정을 컴파일러가 자동으로 수행한다.
```java
sealed interface Entry {}
record IntEntry(int value) implements Entry {}
record StringEntry(String value) implements Entry {}

void processList(List<Entry> list) {
    for (Entry entry : list) {
        switch (entry) {
            case IntEntry(int number) -> processNumber(number);
            case StringEntry(String string) -> processString(string);
        }
    }
}
```
이 코드에서 컴파일러는 switch 문이 `Entry` 인터페이스 상속자를 모두 검사하는지 자동으로 확인한다.
나중에 또 다른 상속자가 추가되면 switch 문에 컴파일 에러가 발생하므로 새로운 case를 추가할 수밖에 없다.