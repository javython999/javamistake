# List.remove() 오버로드 오용
표준 라이브러리의 `Collection.remove(Object)` 메서드는 컬렉션에서 특정 원소를 제거하는 역할을 한다.
또한 `List` 인터페이스는 인덱스 번호로 원소를 제거할 수 있도록 `List.remove(int)` 메서드를 오버로드 형태로 제공한다.
그러나 `List<Integer>` 타입을 다룰 때 이러한 오버로드 메서드의 기능을 혼동하고 잘못 사용하는 경우가 있다.

```java
List<Integer> offsets = getOffsets();
offsets.remove(0);
```
이 코드는 0번 인덱스의 원소를 조건 없이 제거한다. 
그러나 코드 작성자는 리스트 내부에 존재하는 0 값을 제거하려고 했을지도 모른다.
불행히도 이러한 실수는 정적 분석으로 감지하기 어렵다.
원래의 의도가 인덱스 제거였는지 값 제거였는지 판단할 수 없기 때문이다.

> 실수 방지 가이드 
* 요즘 IDE는 파라미터명에 힌트를 줄 수 있다. 이러한 힌트를 주의 깊게 확인해야 한다.
* 실수 069에서 언급했듯이, 박싱된 기본 타입 컬렉션을 멀리하고 FastUtil 등의 서드파티 라이브러리를 사용하는 것이 좋다. 이러한 라이브러리는 더 빠르게 작동하고 적은 메모리를 사용하며 값 제거와 인덱스 제거 기능을 별도의 메서드로 제공한다.
* `remove(Object)` 메서드는 제거 성공 여부를 나타내는 boolean 값을 반환한다.
이를 확인하면 메서드를 잘못 호출했음을 즉시 알 수 있다. 예를 들어 이 번절의 예시 코드가 리스트의 0 값을 제거하려는 의도였다면
다음 과같이 검증하면 된다.
```java
boolean success = offsets.remove(0);
assert success : "Element 0 was not found";
```
이러한 조치로 코드가 더욱 견고해질 뿐만 아니라 어설션 실패 시 컴파일러 에러가 발생하므로 메서드를 잘 못 사용했음을 즉시 알 수 있다.
```java
boolean success = offsets.remove((Integer) 0);
assert success : "Element 0 was not found";
```