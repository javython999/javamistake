# null을 허용하지 않는 컬렉션에서 null을 검색함
다음은 표준 컬렉션과 맵이 `null`을 처리하는 세 가지 기본 원칙이다.

* 컬렉션 내 `null` 원소를 허용함: `ArrayList`, `HashSet`, `Collections.singleton()` 등
* `null` 원소는 불허하지만 `contains()` 등의 검색 메서드는 `null` 인수를 허용하며 검색 결과 부재를 반환함: `ConcurrentLinkedQueue`, `EnumSet`, `ArrayDeque` 등
* `null` 원소를 불허하고 검색 메서드도 `null`을 허용하지 않음: `List.of()`, `Set.of()`, `Map.of()` 등의 팩토리 메서드 밙환 컬렉션과 `ConcurrentHashMap`, `ConcurrentHashMap.newKeySet()`

대부분의 스타일 가이드는 컬렉션을 선언할 때 구체적 클래스 대신 `Set`, `Map`, `List`, `Collection` 등의 인터페이스를 권장한다.
`List.of()`나 `Collections.singletonList()` 등의 팩토리 메서드가 반환하는 타입은 구현 클래스를 전혀 알 수 없으므로 인터페이스로 받을 수 밖에 없기 때문이다.
결국 이렇게 선언된 변수 타입은 `contains(null)`을 호출해도 안전한지 확인할 만한 단서가 없다.

이러한 문제는 이론상으로만 존재할 것 같지만, 기존 자바 8의 코드를 최신 버전으로 마이그레이션 할 때 현실화 된다.
자바 9에서 도입된 새로운 컬렉션 팩토리를 마음껏 쓰고 싶겠지만 다음과 같이 구식으로 제작된 수정이 불가한 컬렉션을 조심해야 한다.

```java
Set<String> PLATFORMS = Collections.unmodifiableSet(
        new HashSet<>(Arrays.asList("PC", "Mac", "Mobile"))
);
```
이런 코드를 보면 다음과 같이 신형 API로 고치고 싶기 마련이다.
```java
Set<String> PLATFORMS = Set.of("PC", "Mac", "Mobile");
```
모든 원소가 `null`이 아닌 문자열 리터럴이므로 이렇게 고쳐도 안전할 것이라 예상하기 쉽다.
그러나 PLATFORMS.contains(str)을 호출하는 곳이 있고 str이 `null`이라면, 이전과 달리 `false`를 반환하는 대신
`NullPointerException` 예외가 발생하며 실패할 것이다.

> 실수 방지 가이드
* 구형의 수정 불가 컬렉션을 신형 컬렉션 팩토리로 무분별하게 교체하지 않는다.
특히 코드베이스의 테스트 커버리지가 높지 않다면 더욱 주의해야 한다.
* obj가 `null`일 가능성이 있다면 `collection.contains(obj)`를 그대로 사용하지 않는다. 코드를 조금 더 보태는 한이 있더라도 
`obj != null && collection.contains(obj)` 처럼 안전한 조건을 만들어야 한다.
