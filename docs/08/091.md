# 약한 참조, 부드러운 참조의 우발적 무효화
자바에서 객체를 변수에 저장하면 실제로는 객체에 대한 참조가 저장된다.
이러한 참조를 강한 참조라 부른다.
특정 객체를 가리키는 참조가 하나라도 있는 한 해당 객체는 가비지 수집기로부터 살아 남는다.
강한 참조 외에 자바 가상 머신은 약한 참조와 부드러운 참조를 지원한다.
이 두 참조는 객체에 강한 참조가 없는 한 파괴해도 괜찮다는 의사를 명시적으로 드러낸다.
가상 머신은 힙 메모리가 부족해지면 이들을 가비지로 수집한다.
이러한 객체는 참조 상태에 대한 약한 도달 객체 또는 부드러운 도달 객체라 부른다.
약한 참조 또는 부드러운 참조를 활용하는 대표적인 사례는 캐싱 객체다.
캐싱 객체는 메모리에 있으면 그대로 쓰고, 없으면 언젠든 재계산하거나 디스크로부터 역직렬화할 수 있는 객체다.
이들을 잘 쓰면 가상 머신이 힙 메모리를 더 효율적으로 관리할 수 있다.

이러한 참조 방식의 문제는 프로그램 실행 중 언제든지 가비지 수집이 발생할 수 있다는 점이다.
약한 도달 또는 부드러운 도달 상태의 객체는 지금 당장 살아있다 해도 단 몇 분 부에는 수집되고 사라질지도 모른다.
심지어 다음과 같은 간단한 코드 조차 `NullPointerException`을 일으킬 수 있다.

```java
Object obj = new Object();
WeakReference<Object> ref = new WeakReference<>(obj);
System.out.println(ref.get().hashCode());
```

obj라는 로컬 변수를 약한 참조를 생성하고 더 이상 사용하지 않으면 약한 도달 상태가 된다.
만일 ref 생성과 ref.get() 호출 사이에 obj 객체가 수집되면 ref.get()은 null을 반환한다.
실제로 OpenJDK의 ResourceBundle 클래스에서 이러한 현상이 발견된 적이 있다.
이 버그는 매우 특정한 시점에 GC가 발생할 경우에만 에러를 일으키므로 몇 년이 지나도록 아무도 알아차리지 못한 채 살아남을 수 있었다.
게다가 JVM이 코드를 실행하는 방식도 이 문제에 영향을 미친다.
가령 핫스팟 JVM 인터프리터는 로컬 변수의 최종 사용 여부를 GC에 활용하지 않을 때도 있다.
이 경우 인터프리터에서 예시 코드를 실행하면 ref.get()이 null을 반환하는 일은 없을 것이다.
그러나 영리한 JIT 컴파일러는 마지막으로 사용된 로컬 변수를 찾아서 배제해버린다.
따라서 특정 스코프 안에 남아 있는 로컬 변수라 해도 GC가 수집할 수 있게 된다.

> 실수 방지 가이드
* WeakReference 또는 SoftReference 객체를 사용할 때, 이들을 가리키는 강한 참조가 없는 한 get() 메서드가 비-널값을 반환한다고 단정하지 않는다.
바로 윗줄에서 참조를 생성했거나 get()을 호출했다 해도 마찬가지다.
get()의 결과가 null인지 매번 확인하고 반복적으로 호출하지 않도록 조심해야 한다. get()의 반환값은 로컬 변수로 저장하는 것이 좋다.
* 변수의 수명이 변수의 스코프 안에서 지속된다고 단정하지 않는다.
실제 컴파일러는 마지막으로 사용됐음이 확인된 변수를 더 이상 기억하지 못할 수 도 있다.
변수의 객체에 강한 참조가 있었다면 마지막 사용 직후 수집될 가능성도 있다. 객체를 꼭 유지해야 한다면 다음과 같이 reachabilityFence() 메서드(자바9 이상)를 통해 변수의 수명을 명시적으로 연장할 수 있다.

```java
Object obj = new Object();
WeakReference<Object> ref = new WeakReference<>(obj);
System.out.println(ref.get().hashCode());
Reference.reachabilityFence(obj);
```
reachabilityFence()의 유일한 기능은 파라미터로 전달 받은 객체를 강한 참조로 유지시키는 것이다.
