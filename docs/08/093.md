# 동시 업데이트 데이터 구조에 대한 비원자적 접근
여러 스레드 사이의 공유 데이터를 다룰 때도 앞 절과 비슷한 문제가 발생한다.
이러한 공유 데이터는 `volatile` 변수나 동시성 컬렉션에 저장된다. 필자는 다음과 비슷한 코드가 동시성 큐에서 실행되는 것을 여러 번 봤다.
```java
void takeAnProcess(Queue<String> queue) {
    if (!queue.isEmpty()) {
        String element = queue.remove();
        ...
    }
}
```
이 코드는 사실상 큐를 두 번 검사한다.
첫 번째는 `isEmpty()` 메서드 안에서, 두 번째는 `remove()` 메서드 안에서 이루어진다.
다시 말해 큐와의 상호작용이 원자적이지 않다.
다른 소비자가 동시에 이 큐에서 원소를 꺼내면 두 검사 사이에 큐가 비워질 가능성이 있다.
이 과정을 더 적절히 처리하려면 다음과 같이 `poll()` 등의 메서드를 한 번만 호출해야 한다.
```java
void takeAnProcess(Queue<String> queue) {
    String element = queue.poll();
    if (element != null) {
        ...
    }
}
```
`remove()`와 달리 `poll()` 메서드 큐가 비었을 때 예외를 던지지 않고 `null`을 반환한다.
따라서 스레드에 영향을 받지 않는 로컬 변수를 통해 `null`을 반환한다.

동시성 맵에 쓰인 구형 `get-and-put` 시퀀스도 에러를 유발하기 쉽다.
예를 들어 다음 코드는 맵의 키마다 접근 횟수를 저장하는 역할을 한다.
```java
void addValue(ConcurrentMap<String, Integer> map, String key) {
    Integer value = map.get(key);
    if (value == null) {
        value = 1;
    } else {
        value++;
    }
    map.put(key, value);
}
```
이 코드도 원자적이지 않다.
서로 다른 스레드가 하나의 맵 항목을 동시에 업데이트하면 잘못된 값이 저장된다.
다행히 자바 8부터 `putIfAbsent()`, `compute()`, `computeIfAbsent()`, `computeIfPresent()`, `merge()` 등의 유용한 메서드가 `Map` 인터페이스에 추가되었다.
이들을 이용하면 대부분 `get-and-put` 시나리오를 원자적으로 구현할 수 있다.
또한 코드를 깔끔해지고 에러는 줄어든다.
방금 예시를 `merge()` 메서드 방식으로 고치면 다음과 같다.
```java
void addValue(ConcurrentMap<String, Integer> map, String key) {
    map.merge(key, 1, Integer::sum);
}
```
이제 동시성 맵이 정확하게 구현되었으니 값이 원자적으로 증가된다.
`AtomicInteger`를 다룰 때도 비슷한 문제가 발생할 수 있다.
가령 `AtomicInteger` 내부의 값을 2배로 늘린다고 가정해보자.
다음과 같이 값을 읽고 2를 곱한 뒤 결과를 저장하는 코드를 떠올리기 쉽다.
```java
atomic.set(atomic.get() * 2);
```
그러나 이 코드는 원자적 연산 처리가 아니므로 스레드 안전을 보장하지 못한다.
두 개의 스레드가 이 코드를 동시에 실행하면 곱셈이 한 번만 수행될 가능성이 있다.
다음과 같이 `updateAndGet()` 메서드를 사용하면 이를 안전하게 구현할 수 있다.
```java
atomic.updateAndGet(value -> value * 2);
```
> 실수 방지 가이드
* 동시성 컬렉션 메서드를 연쇄 호출하면 작업을 원자적으로 처리할 수 없다는 점을 이해해야 한다.
호출 사이에 다른 스레드가 컬렉션을 수정할 가능성이 있다. 컬렉션 설명서를 꼼꼼히 읽고, 처리하고자 하는 작업에 적합한 원자적 연산을 선택해야 한다.
* 동시성 프로그램의 올바른 구현은 복잡하고 어려운 주제다. 실무에 들어가면 이 책에서 언급한 흔한 실수보다 훨씬 다양하고 미묘한 문제들과 마주치게 될 것이다.
이 분야는 무작정 뛰어들기보다 충분히 시간을 들여 기본 개념을 학습하는 것이 좋다.