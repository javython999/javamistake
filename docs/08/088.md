# 열거형, 어노테이션, 클래스에서 getClass()를 사용
열거형 상수와 어노테이션 객체는 통상적으로 `getClass()`가 아닌 다른 방식으로 클래스 정보를 얻는다.
다른 클래스와 달리 예상 밖의 결과가 나올 수 있기 때문이다.
열거형 클래스는 확장할 수 없으므로 개발자는 이를 final 클래스처럼 인식하는 경우가 많고, `getClass()`를 호출하면 자연히 열거형 클래스 자신이 반환될 것이라 기대한다.
이러한 예상은 대체로 들어 맞는다.

```java
enum MyEnum {
    A, B
}
```
`MyEnum.A.getClass()`를 호출하면 예상대로 `MyEnum` 클래스가 반환된다.
그러나 열거형의 각 상수는 다음과 같이 클래스 본문 형태로 선언할 수 있다.
이때 컴파일러는 묵시적으로 A의 익명 클래스를 따로 생성한다.
```java
enum MyEnum {
    A {
        public String toString() {
            return "Customized";
        }
    }, B
}
```
이제 `MyEnum`은 더이상 final이 아니다.
묵시적인 익명 클래스가 본체를 확자하기 때문이다.
결과적으로 `MyEnum.A.getClass()`는 `MyEnum$1` 처럼 생긴 익명 클래스명을 반환한다.
이러한 익명 클래스는 맵 키 또는 비교 대상으로 사용할 수 없다.
열거형은 이러한 문제애 대처할 수 있도록 `getDeclaringClass()` 메서드를 제공한다.
이 메서드는 특정 상수에 클래스 본문이 있어도 항상 열거형 클래스의 본체를 반환한다.

어노테이션 객체에서 `getClass()`를 호출하는 사례는 다소 특수하지만, 알아두어서 나쁠 것은 없다.
먼저 다음과 같이 간단한 어노테이션을 선언해보자.

```java
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {}
```
```java
@MyAnno
public class Main088 {

    public static void main(String[] args) {
        MyAnno annotation = Main088.class.getAnnotation(MyAnno.class);
        System.out.println(annotation.getClass());
    }
}
```
이 코드에서 어노테이션 클래스를 출력하면 `$Proxy1`과 비슷한 값이 나타난다.
이 클래스는 리플렉션 메커니즘이 어노테이션을 표현하기 위해 내부적으로 사용하는 프록시 클래스다.
보통은 이러한 정보가 필요할 일이 없다.
어노테이션 객체의 인터페이스 타입을 알고 싶을 때는 `annotationType()` 메서드를 쓰면 된다.
이 메서드는 모든 어노테이션에서 호출 할 수 있다.

`java.lang.Class`도 자바 객체이므로 `getClass()`를 호출 할 수 있으며
`java.lang.Class` 클래스를 나타내는 `java.lang.Class` 객체가 항상 반환된다.
`java.leng.Class` 객체에서 `getClass()`를 호출하는 코드는 대게 실수일 가능성이 높지만 컴파일러는 이를 딱히 경고하지 않는다.

> 실수 방지 가이드
* Cls 클래스 인스턴트에서 `getClass()`를 호출 했을 때 항상 Cls.class를 반환되지 않는다는 점을 명심하라.
해당 인스턴스는 Cls의 서브클래스일지도 모른다.
게다가 Cls가 열거형일 경우 전혀 예상치 못한 값이 반환될 수 있다.
* 가급적이면 `getClass()` 대신 `instnaceof` 연산자를 사용한다.
* 에러 보고 코드의 실행 경로를 유닛 테스트로 검증하고, 예외 타입은 물론 에러 메시지까지 확인한다.