# 스트림 API 체인에서 부수 효과를 일으킴
자바 8에서 도임된 스트림 API는 플루언트 스타일로 데이터 시퀀스를 처리하는 도구다.
이들은 대부분 직관적이며 정확성 면에서 버그를 내는 경우는 거의 없다.
그러나 원치 않는 사고를 방지하기 위해 개발자가 알아야 할 사항이 몇 가지 있다.

스트림 API는 원천으로부터 스트림을 생성하고 여러 차례의 중간 연산을 거쳐 단 하나의 단말 연산을 처리한다.
스트림을 생성하는 방법은 많지만 아마도 `collection.stream()`처럼 컬렉션으로부터 만들어내는 경우가 가장 흔할 것이다.
`map()`이나 `filter()` 등의 중간 작업은 스트림의 내용을 갱신하고 새로운 스트림을 생성한다.
최종적으로 단말 연산은 이 스트림이 반환할 결과를 만들어 낸다. `count()`, `toArray()`, `collect()` 등이 단말 연산에 속한다.

명심할 점은, 단말 연산을 호출하기 전까지 스트림은 아무것도 처리하지 않는다는 것이다.
중간 연산은 그저 레시피처럼 기억하고 있을 뿐 단말 연산을 호출해야 실제로 조리를 시작한다.

중간 연산이 함수를 입력 받는 경우, 스트림은 이 함수가 부수효과를 일으키지 않는다고 간주한다.
즉 함수의 유일한 결과는 반환값이며 이 함수가 몇 번 호출되든, 혹은 호출되지 않든 프로그램의 상태는 변하지 않아야 한다.
다음은 부수 효과를 일으키는 `filter()` 연산의 예시다.

```java
List<String> containNoNeedle = new ArrayList<>();
List<String> containNoNeedleList = list.stream()
        .filter( str -> {
            if (str.contains("needle")) {
                return true;
            }
            containNoNeedle.add(str);
            return false;
        })
        .toList();
```
이 예시에서 `filter()` 연산에 전달된 함수형 파라미터는 문자열 내용에 따라 `true`, `false`를 반환한다.
그러나 여기에 그치지 않고 다른 컬렉션을 수정하는 부수 효과도 일으킨다.
이로 인해 이 함수는 입력 원소마다 정확히 한 번만 호출되어야 한다는 조건이 생긴다.
그렇지 않으면 `containNoNeedle`의 내용이 계획대로 만들어지지 않는다.
게다가 호출 순서도 중요하다.
이 함수의 호출 순서가 바뀌면 결과도 달라질 것이다. 만일 `stream()` 대신 `parallelStream()`로 여러 스레드에서 이 함수를 동시에 호출 한다면 예외가 발생하거나
데이터가 손실될 위험이 있다. 이러한 상황은 스트림 API의 관용적 사용 행태에 위배된다.
실제로 조건에 따라 입력 스트림을 분할할 때는 다음과 같이 `partitionBy()` 수집기를 쓰는 것이다.

```java
Map<Boolean, List<String>> partitions = list.stream()
        .collect(Collectors.partitioningBy(str -> str.contains("needle")));
```
이렇듯, 중간 연산 과정에서 부수 효과를 두는 것은 지양해야 한다.
`Stream.peek()`은 예외다.
이 메서드의 유일한 용도는 부수 효과를 처리하는 것이며 파라미터 함수는 void를 반환한다.
그러나 공식 문서에 따르면 이 메서드의 두된 용도는 디버깅이다.
또한 전달받은 함수의 무조건적인 실행을 보장하지 않는다고 명시되어있다.
스트림 구현의 최적화에 따라 일부 또는 전체 원소가 걸러지면 이 메서드도 함께 생략되기 때문이다.
실제로 조건에 다라 입력 스트림을 분할 할 때는 다음과 같이 `partitioningBy()` 수집기를 쓰는 것이 표준 방식이다.

```java
Map<Boolean, List<String>> partitions = list.stream()
        .collect(Collectors.partitioningBy(str -> str.contains("needle")));
List<Strig> containNoNeedle = partitions.get(false);
List<Strig> containNoNeedle = partitions.get(true);
```

> 실수 방지 가이드
* 자바 버전마다 스트림 API의 최적화 원리를 기억할 필요는 없다. 차라리 스트림 API 중간 연산에서 부수 효과를 완전히 배제하는 것이 낫다.
* 코드에서 원하는 바를 스트림 API 연산으로 충분히 표현할 수 없다면 for 루프를 고려해도 좋다.
스트림 API가 주는 신선하고 매력적인 인상 덕에 많은 개발자가 이를 우선적으로 쓰려고 하는 경향을 보인다.
그러나 어울리지 않는 작업을 스트림 API 체인에 억지로 끼워 맞추는 것보다 루프를 사용하는 편이 낫다.
* 스트림 API를 확장한 서드파티 라이브러리도 좋은 대안이다. 필자가 제작한 `StreamEx`도 자바 스트림을 확장했으며 부수효과 없이 다양한 연산을 편리하게 처리할 수 있다.