# instanceof 대신 getClass()를 사용
`getClass()` 메서드는 모든 자바 객체에서 사용할 수 있으며 `java.lang.Class` 형태의 런타임 클래스 미러를 반환한다.
런타임 객체 클래스는 각종 진단. 리플렉션, equals() 메서드 구현 등의 다양한 용도로 활용할 수 있다.
`getClass()`의 반환 결과를 클래스 리터럴과 비교하면 `instanceof` 연산자로 객체를 비교하는 것과 비슷한 효과가 있다.
그러나 `instanceof`는 서브 클래스까지 비교하고 `true`를 반환하는 반면, `getClass()`는 정확히 클래스만 비교한다는 점을 잊지 말아야 한다.

```java
if (object.getClass() == ArrayList.class) {
    ...
}

if (object instanceof ArrayList) {
    ...
}
```

비교 대상 클래스가 final 클래스라면 두 조건문 모두 결과는 같다.
그러나 그렇지 않을 경우 둘을 잘 가려서 써야 한다.
```java
static Object convert(Object date) {
    Class<?> cls = date.getClass();

    if (cls == java.util.Date.class) {
        return new java.sql.Date(
                ((java.util.Date) date).getTime());
    }

    if (cls == java.util.Calendar.class) {
        return new java.sql.Date(
                ((java.util.Calendar) date).getTime().getTime());
    }

    return date;
}
```
이 메서드는 날짜를 나타내는 다양한 객체를 `java.sql.Date`로 변환한다.
`java.sql.Date`는 `java.util.Date`의 서브클래스인 점을 감안해, 첫 번째 조건문은 `instanceof java.util.Date` 대신 `getClass()`로 비교 했다.
입력값이 이미 `java.sql.Date`라면 있는 그대로 반환하려 했기 때문이다.
그러나 첫 번쨰와 같은 방식으로 두 번째 if 문에서 클래스를 비교한 부분은 실수다.
작성자는 아마도 두 조건문을 일관적 형태로 유지하려 했을 것이다.
두 번쨰if 문은 객체 클래스가 정확히 `java.util.Calendar`인 경우에만 실행된다.
그러나 `Calendar`는 추상 클래스이므로 이러한 조건을 만족시키는 경우는 없다.
모든 `Calendar` 인스턴스는 일종의 서브클래스이며, 특히 다음과 같이 `GregorianCalendar`가 할당되는 경우가 많다.

```java
Calendar obj = Calendar.getInstance();
System.out.println(obj.getClass());
```

따라서 두 번째 if 문은 절대로 실행되지 않으며 `Calendar` 인스턴스는 의도와 달리 `java.sql.Date`로 변환되지 않는다.

> 실수 방지 가이드 
* `getClass()`를 신중하게 사용한다. '이곳에 서브클래스가 올 가능성이 있는가? 그럴 때는 어떻게 작동해야 하는가?' 등의 의문을 반드시 해소해야 한다.
`instanceof` 대신 `getClass()`를 사용할 때마다 주석으로 설명하는 것이 좋다.
* cls 인스턴스의 클래스를 특정할 수 없고 컴파일타임 클래스를 확인해야 할 때는 `cls.equals(object.getClass())` 보다 `cls.isInstanceof(object)`를 먼저 고려한다.
* 클래스는 일단 final로 선언하고 상속될 것이 확실할 때만 명시적으로 허용한다.
이렇게 하면 서브클래스 인스턴스가 코드에 언제 등장할지, 어떻게 작동할지 고민할 필요가 없다.