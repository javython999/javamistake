# 스트림 API 연산 계약 위반
스트림 API는 스트림 연산 인수를 매우 엄격하게 제한한다.
대표적으로 `Stream.reduce(identity, accumulator)` 메서드를 살펴보자.
첫 번째 `항등원` 인수는 스트림 원소와 같은 타입의 값이며, 두 번째 인수는 두 개의 원소를 받아 하나의 결과를 만들어내는 함수다.
메서드 스펙에 따르면 누적 연산은 결합 법칙을 따라야 하며 한쪽 피연사자가 항등원일 때 다른 쪽 피연산자를 그대로 반환해야 한다.
즉 모든 x, y, z에 대해 다음과 같은 명제가 성립한다.
* x ◎ i = x
* i ◎ x = x
* x ◎ (y ◎ z) = (x ◎ y) z

여기서 i는 항등원을 x ◎ y는 `accumulator.apply(x, y)`를 의미한다.
그러나 막상 스트림 API를 사용하면 이러한 원칙을 무시해도 어쨌든 작동한다는 사실을 금세 알 수 있다.
스펙애 따르면 `List.hashCode()`는 다음 알고리즘을 따라야 한다.
```java
int hashCode = 1;
for (E e : list) {
    hashCode = 31*hashCode + (e == null ? 0 : e.hashCode());    
}
```

이 코드를 `Stream.reduce()`로 다음과 같이 구현하면 실제로 작동한다.
```java
List<String> list = List.of("a", "b", "c", "d");

System.out.println(list.hashCode()); // 3910595
System.out.println(
        list.stream()
                .mapToInt(Objects::hashCode)
                .reduce(1, (x, y) -> x * 31 + y)
); // 3910595
```
그러나 이 누적 연산은 명백히 결합 법칙을 지키지 않으며 항등원도 제 구실을 못한다.
메서드 계약에 따르면 누적 연산에 (1, 10)을 적용하면 1이 항등원이므로 결과는 10이 되어야 한다.
그러나 실제 반환 결과는 41이다.
그럼에도 불구하고 코드는 올바른 계산 결과를 낸다.

실질적으로 스트림 API 인수의 요구 사항은 대부분 병렬 스트림 작동 시 필요한 것으로 보인다.
앞의 예시에서 `stream()`을 `parallelStream()`으로 바꾸면 완전히 틀린 계산 결과를 얻는다.
계산 순서가 달라지기 때문이다.

```java
System.out.println(
        list.stream()
                .parallel()
                .mapToInt(Objects::hashCode)
                .reduce(1, (x, y) -> x * 31 + y)
); // 131168
```
이러한 불일치는 흥미로운 상황을 만든다.
현실에서 스트림 API 호출 현황을 조사하면 이렇듯 스펙을 위반하는 API가 상당수 발견될 것이다.
그럼에도 불구하고 이들은 병렬로 실행되지 않아서 정상적으로 작동한다.

이러한 스트림 체인이 여러 메서드 호출에 걸쳐 있다면 더욱 위험하다.
메서드에서 스트림을 반환한거나 파라미터로 받는다고 가정해보자.

```java
static int hashCode(Stream<?> stream) {
    return stream.mapToInt(Objects::hashCode)
            .reduce(1, (x, y) -> x * 31 + y);
}
```

이 메서드는 병렬 스트림을 입력 받으면 반환값이 달라진다. 그 결과는 심지어 프로세서 코어 수에 따라 달라지기도 한다.
JVM 실행 시 `Djava.util.councurrent.ForkJoinPool.common.paralleism=X` 옵션을 주고 실행하면 하드웨어를 바꾸지 않아도 직접 확인할 수 있다.
여기에 `IntStream.range(0, 1000).boxed().parallel()`처럼 덩치가 큰 스트림을 입력하면 `ForkJoinPool`이 작동하며 병렬 처리 청크 수를 조절한다.
그 결과, 누적 함수적용 순서가 바뀔 수 있다.

이 문제를 굳이 스트림 API로 해결하기 원한다면 스트림 원소를 정확히 왼쪽에서 오른쪽으로 순차적으로 처리해야 한다.
다음과 같이 `forEachOrdered()` 연산을 적용하면 그렇게 할 수 있지만, 썩 보기 좋은 모습은 아니다.

```java
static int hashCodeOf(Stream<?> stream) {
    var op = new IntConsumer() {
        int acc = 1;
        public void accept(int value) {
            acc = acc * 31 + value;
        }
    };
    
    stream.mapToInt(Objects::hashCode)
            .forEachOrdered(op);
    return op.acc;
}
```
이제 이 코드는 병렬 스트림과 순차 스트림에서 모두 잘 작동할 것이다.
물론 `forEachOrdered()`를 쓰면 대부분의 스트림이 병렬화의 이점을 누리지 못하게 된다.
그러나 업스트림 연산량이 매우 많다면 병렬 스트림 쪽이 더 빠를 가능성은 있다.

> 실수 방지 가이드 
* 스트림 API 계약을 신중하게 따른다. 특히 스트림의 모든 작업을 통제할 수 없다면 더욱 철저히 준수해야 한다.
* 스트림 소비, 생성 유틸리티 메서드를 만들 때는 `parallel()` 테스트를 잊지 말아야 한다.
* 스트림 API로 모든 문제를 해결하려 하지 않는다. 스트림 API는 다양한 데이터 작업을 처리할 수 있는 유용한 도구다.
그러나 이번 절의 리스트 해시코드 예시처럼 정형화된 방식으로 해결할 수 없는 문제도 많다.
이러한 경우 서드파티 라이브러리를 검토하거나 전통적인 for 루프를 사용하는 편이 낫다.